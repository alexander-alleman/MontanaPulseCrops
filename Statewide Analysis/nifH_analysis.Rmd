---
title: "Montana Statewide nifH Analysis"
author: "Alexander Alleman"
date: "January 23, 2019"
output:
  pdf_document:
    df_print: kable
  word_document: default
  html_document: default
---
```{r echo=FALSE}
gsub("[[:punct:][:space:]]", "-", Sys.time())
```

####Working Directory
```{r echo=FALSE}
getwd()
```


```{r}
set.seed(8765)
```

###Load packages
```{r warning=FALSE,message=FALSE}
library(ggplot2)
library(data.table)
library(vegan)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(phyloseq)
library(ggpubr)
library(RColorBrewer)
library(ape)
library(grid)
#library(knitr)
library(igraph)
library(Matrix)
library(ggnetwork)
library(intergraph)
library(Hmisc)
library(parallel)
library(ggrepel)
library(tinytex)
```

####Colors
```{r}
farm_col<-(c("#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"))
farm_col_dark<-brewer.pal(7, "Dark2")
farm_col_paired<-(c('#fdbf6f','#ff7f00','#b2df8a','#33a02c','#fb9a99','#e31a1c','#cab2d6','#a6cee3','#1f78b4'))
farm_col_paired<-(c('#fdbf6f','#ff7f00','#b2df8a','#33a02c','#fb9a99','#e31a1c','#cab2d6','#a6cee3','#1f78b4', 'black'))
```

***
##Load OTU, Taxa, and Meta data

####Add OTU table with sample names on top and OTU names as row names 
```{r}
OTU_nifH<- read.delim(
  "~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/nifH_OTUallspring.csv",
  row.names = 1)
head(OTU_nifH)[,1:10]
```



####These taxa were also created by Mr. DNA through a blast program and the NCBI database
```{r}
tax_nifH<- read.delim(
  "~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/nifH_OTU_ids_2016_fixed1.txt", 
  row.names = 1)
head(tax_nifH)[,1:8]
```

####Meta data set has be placed together from all the spring and summer data with excel
```{r}
meta<- read.delim(
  "~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/all_metadata_summer.csv",                    row.names = 1, na.strings = "NA", sep = ",",
                  colClasses = c(rep('factor', 7), rep('numeric', 3), rep('factor', 4), 'numeric',
                                 rep('factor', 3), rep('numeric', 28) ) )
head(meta)[,1:5]
```




####Removed all Havre for analysis because samples were taken in 6" sections instead of 12"
```{r}
meta2 <- meta[-c(19:48),]
sapply(meta2, class)
```

####Convert to matrix 

```{r}
OTU_nifH_m<-as.matrix(OTU_nifH)
tax_nifH_m<-as.matrix(tax_nifH)
meta_m<-as.matrix(meta2)

class(OTU_nifH_m)
class(tax_nifH_m)
class(meta_m)

```


####Make phyloseq object
```{r}
OTUnifH = otu_table(OTU_nifH_m, taxa_are_rows = TRUE)
TAXnifH = tax_table(tax_nifH_m)

physeq_nifH = phyloseq(OTUnifH, TAXnifH)
```


####Get physeq info
```{r}
physeq_nifH
```

###Add meta data to phyloseq object 

```{r}
meta_phy <- sample_data(meta2)
sample_names(meta_phy)
```

```{r}
physeq_nifH<-merge_phyloseq(physeq_nifH, meta_phy)
physeq_nifH
```
```{r}
physeq_nifH<-rarefy_even_depth(physeq_nifH)
physeq_nifH
```

```{r}
OTU_nifH_rare = as(otu_table(physeq_nifH), "matrix")
OTU_nifH_rare = as.data.frame(OTU_nifH_rare)
```
***
#Trim data
###Trim data to exclude OTUs that are not in any samples 
Source of trim protocol
http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html#taxa-total-counts-histogram

```{r}
tdt_nifH = data.table(tax_table(physeq_nifH),
                 TotalCounts = taxa_sums(physeq_nifH),
                 OTU = taxa_names(physeq_nifH))
ggplot(tdt_nifH, aes(TotalCounts)) + 
  geom_histogram() + 
  ggtitle("Histogram of Total Counts nifH")
```
```{r}
# How many OTUS have low count (Rare)?
tdt_nifH[(TotalCounts <= 0), .N]#zero count
tdt_nifH[(TotalCounts <= 1), .N]#single count
tdt_nifH[(TotalCounts <= 2), .N]#double count
```
```{r}

# taxa cumulative sum
taxcumsum_nifH = tdt_nifH[, .N, by = TotalCounts]
setkey(taxcumsum_nifH, TotalCounts)
taxcumsum_nifH[, CumSum := cumsum(N)]
# Define the plot
pCumSum_nifH = ggplot(taxcumsum_nifH, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold (nifH)")
pCumSum_nifH
```

####Zoom in 

```{r warning=FALSE}
pCumSum_nifH + xlim(0, 100)
```

####So if we filter ~9 Total count so remove every OTU with less than 9 counts we would remove 5000 OTUs. If we remove OTUS with less than 3 counts per OTU we only remove ~2900 OTUS. 

####We will now to the same with OTU prevlenace (How many samples is the OTU in)


```{r echo=FALSE}
# Define some functions for quick taxa summary

fast_melt = function(physeq,
                     includeSampleVars = character(),
                     omitZero = FALSE){
  require("phyloseq")
  require("data.table")
  # supports "naked" otu_table as `physeq` input.
  otutab = as(otu_table(physeq), "matrix")
  if(!taxa_are_rows(physeq)){otutab <- t(otutab)}
  otudt = data.table(otutab, keep.rownames = TRUE)
  setnames(otudt, "rn", "TaxaID")
  # Enforce character TaxaID key
  otudt[, TaxaIDchar := as.character(TaxaID)]
  otudt[, TaxaID := NULL]
  setnames(otudt, "TaxaIDchar", "TaxaID")
  # Melt count table
  mdt = melt.data.table(otudt, 
                        id.vars = "TaxaID",
                        variable.name = "SampleID",
                        value.name = "count")
  if(omitZero){
    # Omit zeroes and negative numbers
    mdt <- mdt[count > 0]
  }
  # Omit NAs
  mdt <- mdt[!is.na(count)]
  # Calculate relative abundance
  mdt[, RelativeAbundance := count / sum(count), by = SampleID]
  if(!is.null(tax_table(physeq, errorIfNULL = FALSE))){
    # If there is a tax_table, join with it. Otherwise, skip this join.
    taxdt = data.table(as(tax_table(physeq, errorIfNULL = TRUE), "matrix"), keep.rownames = TRUE)
    setnames(taxdt, "rn", "TaxaID")
    # Enforce character TaxaID key
    taxdt[, TaxaIDchar := as.character(TaxaID)]
    taxdt[, TaxaID := NULL]
    setnames(taxdt, "TaxaIDchar", "TaxaID")
    # Join with tax table
    setkey(taxdt, "TaxaID")
    setkey(mdt, "TaxaID")
    mdt <- taxdt[mdt]
  }
  # includeSampleVars = c("DaysSinceExperimentStart", "SampleType")
  # includeSampleVars = character()
  # includeSampleVars = c()
  # includeSampleVars = c("aksjdflkas") 
  wh.svars = which(sample_variables(physeq) %in% includeSampleVars)
  if( length(wh.svars) > 0 ){
    # Only attempt to include sample variables if there is at least one present in object
    sdf = as(sample_data(physeq), "data.frame")[, wh.svars, drop = FALSE]
    sdt = data.table(sdf, keep.rownames = TRUE)
    setnames(sdt, "rn", "SampleID")
    # Join with long table
    setkey(sdt, "SampleID")
    setkey(mdt, "SampleID")
    mdt <- sdt[mdt]
  }
  setkey(mdt, "TaxaID")
  return(mdt)
}

summarize_taxa = function(physeq, Rank, GroupBy = NULL){
  require("phyloseq")
  require("data.table")
  Rank <- Rank[1]
  if(!Rank %in% rank_names(physeq)){
    message("The argument to `Rank` was:\n", Rank,
            "\nBut it was not found among taxonomic ranks:\n",
            paste0(rank_names(physeq), collapse = ", "), "\n",
            "Please check the list shown above and try again.")
  }
  if(!is.null(GroupBy)){
    GroupBy <- GroupBy[1]
    if(!GroupBy %in% sample_variables(physeq)){
      message("The argument to `GroupBy` was:\n", GroupBy,
              "\nBut it was not found among sample variables:\n",
              paste0(sample_variables(physeq), collapse = ", "), "\n",
              "Please check the list shown above and try again.")
    }
  }
  # Start with fast melt
  mdt = fast_melt(physeq)
  if(!is.null(GroupBy)){
    # Add the variable indicated in `GroupBy`, if provided.
    sdt = data.table(SampleID = sample_names(physeq),
                     var1 = get_variable(physeq, GroupBy))
    setnames(sdt, "var1", GroupBy)
    # Join
    setkey(sdt, SampleID)
    setkey(mdt, SampleID)
    mdt <- sdt[mdt]
  }
  # Summarize
  if(!is.null(GroupBy)){
    summarydt = mdt[, list(meanRA = mean(RelativeAbundance),
                           sdRA = sd(RelativeAbundance),
                           minRA = min(RelativeAbundance),
                           maxRA = max(RelativeAbundance)),
                    by = c(Rank, GroupBy)]
  } else {
    Nsamples = nsamples(physeq)
    # No GroupBy argument, can be more precise with the mean, sd, etc.
    summarydt = mdt[, list(meanRA = sum(RelativeAbundance) / Nsamples,
                           sdRA = sd(c(RelativeAbundance, numeric(Nsamples - .N))),
                           minRA = ifelse(test = .N < Nsamples,
                                          yes = 0L, 
                                          no = min(RelativeAbundance)),
                           maxRA = max(RelativeAbundance)),
                    by = c(Rank)]
  }
  return(summarydt)
}

plot_taxa_summary = function(physeq, Rank, GroupBy = NULL){
  require("phyloseq")
  require("data.table")
  require("ggplot2")
  # Get taxa summary table 
  dt1 = summarize_taxa(physeq, Rank = Rank, GroupBy = GroupBy)
  # Set factor appropriately for plotting
  RankCol = which(colnames(dt1) == Rank)
  setorder(dt1, -meanRA)
  dt1[, RankFac := factor(dt1[[Rank]], 
                          levels = rev(dt1[[Rank]]))]
  dt1[, ebarMax := max(c(0, min(meanRA + sdRA))), by = eval(Rank)]
  dt1[, ebarMin := max(c(0, min(meanRA - sdRA))), by = eval(Rank)]
  # Set zeroes to one-tenth the smallest value
  ebarMinFloor = dt1[(ebarMin > 0), min(ebarMin)]
  ebarMinFloor <- ebarMinFloor / 10
  dt1[(ebarMin == 0), ebarMin := ebarMinFloor]
  
  pRank = ggplot(dt1, aes(x = meanRA, y = RankFac)) +
    scale_x_log10() +
    xlab("Mean Relative Abundance") +
    ylab(Rank) +
    theme_bw()
  if(!is.null(GroupBy)){
    # pRank <- pRank + facet_wrap(facets = as.formula(paste("~", GroupBy)))
    pRank <- pRank + geom_point(mapping = aes_string(colour = GroupBy),
                                size = 5)
  } else {
    # Don't include error bars for faceted version
    pRank <- pRank + geom_errorbarh(aes(xmax = ebarMax,
                                        xmin = ebarMin))
  }
  return(pRank)
}
```

```{r}
mdt_nifH = fast_melt(physeq_nifH)
prevdtnifH = mdt_nifH[, list(Prevalence = sum(count > 0), 
                    TotalCounts = sum(count)),
             by = TaxaID]
```

```{r}
ggplot(prevdtnifH, aes(Prevalence)) + 
  geom_histogram() + 
  ggtitle("Histogram of Taxa Prevalence nifH")
```
```{r}
# How many OTUS have low prevelance (Rare)?
prevdtnifH[(Prevalence <= 0), .N]#zero 
prevdtnifH[(Prevalence <= 1), .N]#single 
prevdtnifH[(Prevalence <= 2), .N]#double 
prevdtnifH[(Prevalence >= 54), .N]#how many OTUS are in every sample
```



```{r}
prevcumsumnifH = prevdtnifH[, .N, by = Prevalence]
setkey(prevcumsumnifH, Prevalence)
prevcumsumnifH[, CumSum := cumsum(N)]
pPrevCumSumnifH = ggplot(prevcumsumnifH, aes(Prevalence, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Prevalence") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pPrevCumSumnifH
```

```{r warning=FALSE}
ggplot(prevdtnifH, aes(Prevalence, TotalCounts)) + 
  geom_point(size = 2, alpha = 0.5) + 
  scale_y_log10()
```

####There is a good a good distribution of the OTUs the OTUs that occur in low abundnace also occur in low prevlance. By removing some of the low counts (below ) we will not be losing on the similarities between sites. 


***


##Trimming

####Remove less than doublets in data  and prevlant in 5% of the sample

####First transform to realtive abundance

```{r}
physeq_nifH_trim = filter_taxa(physeq_nifH, function(x) sum(x > 2) > (0.05*length(x)),
                               TRUE)
physeq_nifH_trim
```
```{r}
OTU_nifH_trim_1 = as(otu_table(physeq_nifH_trim), "matrix")
OTU_nifH_trim_df = as.data.frame(OTU_nifH_trim_1)
```

####To simplfy ordination and save time we will trim the OTUs more 

####Remove OTUs that do not show appear more than 5 times in more than 10th of the samples

```{r}
wh0_n = genefilter_sample(physeq_nifH_trim, filterfun_sample(function(x) x > 3), 
                          A=0.1*nsamples(physeq_nifH_trim))
physeq_nifH_ord = prune_taxa(wh0_n, physeq_nifH_trim)
physeq_nifH_ord
```

####Transform to even sampling depth

```{r}
physeq_nifH_ord = transform_sample_counts(physeq_nifH_ord, function(x) 1E6 * x/sum(x))
physeq_nifH_ord
```

#### We have removed the majorty of the low abundance data with a remaining 804 taxa which make the data analysis much more managable.


***

#Analysis

***

##Alpha Diveristy Analysis
###Bar plots 

```{r}
physeq_nifH_ord_2_phylum <- tax_glom(physeq_nifH_ord, "phylum")
plot_bar(physeq_nifH_ord_2_phylum, x = "Site", fill = "phylum")+
geom_bar(aes(fill = phylum), color = "black", stat = "identity", position = "stack", 
         show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c("#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", 
                            "#f0027f",'#e31a1c'),
                   labels = c("Actinobacteria", "Bacteroidetes", "Cyanobacteria", 
                              "Firmicutes", "Proteobacteria", "Verrucomicrobia"),
                  guide = guide_legend(reverse = TRUE)
                    )+
ggtitle("nifH Phylum Relative Abundance by Site")+
ylab("Relative Abundance (%)")+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(),
      panel.background = element_blank())
```
```{r}
physeq_nifH_ord_2_phylum <- tax_glom(physeq_nifH_ord, "phylum")
plot_bar(physeq_nifH_ord_2_phylum, x = "Site", fill = "phylum")+
geom_bar(aes(fill = phylum), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c("#7fc97f", "#beaed4", "#fdc086", "#ffff99", 
                            "#386cb0", "#f0027f"),
                   labels = c("Actinobacteria", "Bacteroidetes", "Cyanobacteria",
                              "Firmicutes", "Proteobacteria", "Verrucomicrobia"),
                  guide = guide_legend(reverse = TRUE)
                    )+
ggtitle("nifH Phylum Relative Abundance by Site")+
ylab("Relative Abundance (%)")+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(), 
      panel.background = element_blank())
```

####Reduce phylums that contribute the less than 5% of total abundance into one group
```{r}
physeq_nifH_ord_1 = transform_sample_counts(physeq_nifH_ord, function(x) x / sum(x) )
physeq_nifH_ord_phylum <- tax_glom(physeq_nifH_ord_1, "phylum")
data_nifH_phylum <- psmelt(physeq_nifH_ord_phylum)
data_nifH_phylum$phylum<-as.character(data_nifH_phylum$phylum)
data_nifH_phylum$phylum[data_nifH_phylum$Abundance<0.05]<-"<5% abdund"

#list new phylums 
unique(data_nifH_phylum$phylum)
```
```{r}
ggplot(data = data_nifH_phylum, aes(x = Site, y = Abundance, fill = phylum))+
geom_bar(aes(fill = phylum), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c( "#33a02c",  "#b2df8a","#a6cee3", "#1f78b4"),
                   breaks=c("p__proteobacteria", "p__firmicutes", 
                            "p__actinobacteria","<5% abdund" ),
                   labels = c( "Proteobacteria", "Firmicutes", 
                               "Actinobacteria", "<5% Abundance"),
                  guide = guide_legend(reverse = TRUE)
                    )+
ggtitle("nifH Phylum Relative Abundance by Site")+
ylab("Relative Abundance (%)")+
scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", 
                            "Huntley Irrigated", "Kalispell", "Moccasin",
                            "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), 
      axis.text.y = element_blank(), panel.background = element_blank())
```

####Publish plot to tiff
When published bars lose little white lines

```{r echo=FALSE}
tiff("nifH_barplot.tiff", width = 6, height = 4, units = 'in', res = 600)
ggplot(data = data_nifH_phylum, aes(x = Site, y = Abundance, fill = phylum))+
geom_bar(aes(fill = phylum), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c( "#33a02c",  "#b2df8a","#a6cee3", "#1f78b4"),
                   breaks=c("p__proteobacteria", "p__firmicutes", 
                            "p__actinobacteria","<5% abdund" ),
                   labels = c( "Proteobacteria", "Firmicutes", 
                               "Actinobacteria", "<5% Abundance"),
                  guide = guide_legend(reverse = TRUE)
                    )+
ggtitle("nifH Phylum Relative Abundance by Site")+
ylab("Relative Abundance (%)")+
scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", 
                            "Huntley Irrigated", "Kalispell", "Moccasin",
                            "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), 
      axis.text.y = element_blank(), panel.background = element_blank())
dev.off()
```

####Different Colors 

```{r}
ggplot(data = data_nifH_phylum, aes(x = Site, y = Abundance, fill = phylum))+
geom_bar(aes(fill = phylum), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c("#a6cee3", "#33a02c",  "#b2df8a", "#ff7f00"),
                   breaks=c("p__proteobacteria", "p__firmicutes", 
                            "p__actinobacteria","<5% abdund" ),
                   labels = c( "Proteobacteria", "Firmicutes", 
                               "Actinobacteria", "<5% Abundance"),
                  guide = guide_legend(reverse = TRUE)
                    )+
ggtitle("nifH Phylum Relative Abundance by Site")+
ylab("Relative Abundance")+
scale_x_discrete(labels = c("Conrad", "Corvallis", 
                            "Huntley Dryland", "Huntley Irrigated", "Kalispell", 
                            "Moccasin", "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), 
      axis.text.y = element_blank(), panel.background = element_blank())
```

###nifH genus barplot

```{r}
physeq_nifH_ord_1 = transform_sample_counts(physeq_nifH_ord, function(x) x / sum(x) )
physeq_nifH_ord_genus <- tax_glom(physeq_nifH_ord_1, "genus")
data_nifH_genus <- psmelt(physeq_nifH_ord_genus)
data_nifH_genus$genus<-as.character(data_nifH_genus$genus)
data_nifH_genus$genus[data_nifH_genus$Abundance<0.1]<-"<10% abdund"
unique(data_nifH_genus$genus)
```

```{r}
ggplot(data = data_nifH_genus, aes(x = Site, y = Abundance, fill = genus))+
geom_bar(aes(fill = genus), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Genus", 
                  values=c('#a6cee3','#1f78b4','#b2df8a','#33a02c',
                           '#fb9a99','#e31a1c','#fdbf6f','#ff7f00',
                           '#cab2d6','#6a3d9a','#ffff99','#b15928'),
                  breaks=c("<10% abdund", "g__agrobacterium", "g__arthrobacter", 
                            "g__bradyrhizobium","g__dechloromonas","g__geobacter",
                           "g__gluconacetobacter", "g__paenibacillus", 
                           "g__rhizobium", "g__rhodopseudomonas"),
                  labels=c("<10% abdund", "Agrobacterium", "Arthrobacter", 
                            "Bradyrhizobium","Dechloromonas","Geobacter",
                           "Gluconacetobacter", "Paenibacillus",
                           "Rhizobium", "Rhodopseudomonas"),
                  guide = guide_legend(reverse = FALSE)
                    )+
ggtitle("nifH Genus Relative Abundance by Site")+
ylab("Relative Abundance")+
scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", 
                            "Huntley Irrigated", "Kalispell", "Moccasin", 
                            "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(),
      panel.background = element_blank())
```

####Publish to a tiff image
```{r echo=FALSE}
tiff("nifH_genus_barplot.tiff", width = 6, height = 4, units = 'in', res = 600)
ggplot(data = data_nifH_genus, aes(x = Site, y = Abundance, fill = genus))+
geom_bar(aes(fill = genus), stat = "identity", position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Genus", 
                  values=c('#a6cee3','#1f78b4','#b2df8a','#33a02c',
                           '#fb9a99','#e31a1c','#fdbf6f','#ff7f00',
                           '#cab2d6','#6a3d9a','#ffff99','#b15928'),
                  breaks=c("<10% abdund", "g__agrobacterium", "g__arthrobacter", 
                            "g__bradyrhizobium","g__dechloromonas","g__geobacter",
                           "g__gluconacetobacter", "g__paenibacillus", 
                           "g__rhizobium", "g__rhodopseudomonas"),
                  labels=c("<10% abdund", "Agrobacterium", "Arthrobacter", 
                            "Bradyrhizobium","Dechloromonas","Geobacter",
                           "Gluconacetobacter", "Paenibacillus",
                           "Rhizobium", "Rhodopseudomonas"),
                  guide = guide_legend(reverse = FALSE)
                    )+
ggtitle("nifH Genus Relative Abundance by Site")+
ylab("Relative Abundance")+
scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", 
                            "Huntley Irrigated", "Kalispell", "Moccasin", 
                            "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(),
      panel.background = element_blank())
dev.off()
```

***

##Alpha diversity metrics 

####Use phyloseq internal packages to calculate the alpha diversity 

```{r warning=FALSE}
plot_richness(physeq_nifH_trim)
```


####Simplify to just Observed, Chao1, and Shannon

```{r warning=FALSE}
plot_richness(physeq_nifH_trim, measures = c("Observed","Chao1", "Shannon"), color = "Site")
```


```{r}
rich_nifH<-estimate_richness(physeq_nifH_trim, split = TRUE)


#First merge data sets with meta2 
meta2$sample_names<-rownames(meta2)
rich_nifH$sample_names<-rownames(rich_nifH)
meta_nifH<-merge(meta2, rich_nifH, by = "sample_names")
rownames(meta_nifH)<-meta_nifH$sample_names
meta_nifH<-meta_nifH[,-1]
head(meta_nifH)[,49:54]
```

```{r}
mean(meta_nifH$Observed)
```

####Make boxplots with Observed, Shannon, chao1, and inverse simpson 

```{r}
#use ggpubr for plot 
nifH_Observ<-ggboxplot(meta_nifH, x = "Site", y = "Observed",
   rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_Shannon<-ggboxplot(meta_nifH, x = "Site", y = "Shannon",
    rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_Chao<- ggboxplot(meta_nifH, x = "Site", y = "Chao1",
    rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

nifH_InvSim<- ggboxplot(meta_nifH, x = "Site", y = "InvSimpson",
   rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

alpha_nifH_fig<-ggarrange(nifH_Observ, nifH_Shannon, nifH_Chao, nifH_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_fig, top = text_grob("Alpha Diversity of nifH ", size = 20))   
```
```{r}
nifH_Observ_stats<-ggplot_build(nifH_Observ)
nifH_Observ_stats$data
```

Publish to .tiff
```{r echo=FALSE}
tiff("aDiv_nifH.tiff", width = 8, height = 4.5, units = 'in', res = 600)

alpha_nifH_fig<-ggarrange(nifH_Observ, nifH_Shannon, nifH_Chao, nifH_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_fig, top = text_grob("Alpha Diversity of nifH ", size = 20)) 
dev.off()
```


####**Observed**- total observed OTUs
####**Chao1**- estimate diversity and	assumes	that the	number	of	observations for	a	taxa	has	a	Poisson	distribution	and	corrects	for	variance
####**Shannon**- Number of OTUs (richness) scaled to the evenness 
####**Simpson**- scale of dominace probabilty of any two indviduals drawn at random beloging to the same species 

Source:
http://biology.kenyon.edu/courses/biol229/diversity.pdf

```{r}
nifH_shannon<-ggboxplot(meta_nifH, x = "Site", y = "Shannon",
   rug = TRUE,
   fill = "Site", xlab = " ", ylab = " ", width = 0.4, title = "nifH",
   palette = farm_col_paired,
   legend = "right"
   )+
  rremove("x.text")
  
```
```{r}
tiff("shannon_nifH.tiff", width = 5, height = 8, units = 'in', res = 600)
nifH_shannon
  
dev.off()
```
```{r}
nifH_Observ_stats<-ggplot_build(nifH_Observ)
nifH_Observ_stats$data
```
```{r}
nifH_otu_count<-as.data.frame(sample_sums(physeq_nifH_trim))
nifH_otu_count$sample_names<-rownames(nifH_otu_count)
```



####Determine if distrubution is normal for each diversity Metric
####Used the following protocol :
https://rpubs.com/dillmcfarlan/R_microbiotaSOP

```{r}
#Create 2x2 plot environment so that we can see all 4 metrics at once. 
par(mfrow = c(3, 2))

#Then plot each metric.
hist(rich_nifH$Observed, main="Observed OTUs", xlab="", breaks=15)
hist(rich_nifH$Shannon, main="Shannon diversity", xlab="", breaks=10)
hist(rich_nifH$InvSimpson, main="Inverse Simpson diversity", xlab="", breaks=15)
hist(rich_nifH$Chao1, main="Chao richness", xlab="", breaks=15)
hist(rich_nifH$ACE, main="ACE richness", xlab="", breaks=15)

```

####Test for normalcy using the shapiro test. The null hypothesis for this test is that the data are normally distributed, if the p-value is greater than 0.05, then the null hypothesis is not rejected.

```{r}
shapiro.test(rich_nifH$Observed)
shapiro.test(rich_nifH$Shannon)
shapiro.test(rich_nifH$InvSimpson)
shapiro.test(rich_nifH$Chao1)
shapiro.test(rich_nifH$ACE)
```


####Use ANOVA on alpha diveristy metrics for Shannon variables becuase the other are not normal 

####Shannon anova 
```{r}
aov_shannon_site_nifH <- aov(Shannon ~ Site, meta_nifH)
summary(aov_shannon_site_nifH)
```
####Site location has a signifcant effect on shannon diversity 


####Correct for multiple comparisons
```{r}
shannon_nifH_site<-TukeyHSD(aov_shannon_site_nifH, "Site", ordered = TRUE)
shannon_nifH_site
```
Write to table

```{r echo=FALSE}
shannon_nifH_site_df<- as.data.frame(shannon_nifH_site$Site)
write.table(shannon_nifH_site_df, file = "shannon_nifH_site.txt", sep = "\t", quote = FALSE, row.names = T)
```

####Plot Irrigation managment against diffrent diveristies  

```{r}
nifH_irr_Observ<-ggboxplot(meta_nifH, x = "Plot", y = "Observed",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_irr_Shannon<-ggboxplot(meta_nifH, x = "Plot", y = "Shannon",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_irr_Chao<- ggboxplot(meta_nifH, x = "Plot", y = "Chao1",
    rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

nifH_irr_InvSim<- ggboxplot(meta_nifH, x = "Plot", y = "Simpson",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

alpha_nifH_irr_fig<-ggarrange(nifH_irr_Observ, nifH_irr_Shannon, nifH_irr_Chao, nifH_irr_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_irr_fig, top = text_grob("Alpha Diversity of nifH by Irrigation", size = 20))   
```

####Check for significance in the other metrics to for irrigation (Dryland vs irrigated)
####Since Shannon was the only normally distributed data set I will use Kruskal Wallis test for others 
```{r}
KW_observed_irr_nifH <- kruskal.test(Observed ~ Plot, meta_nifH)
KW_observed_irr_nifH
```


```{r}
aov_observed_irr_nifH <- aov(Observed ~ Plot, meta_nifH)
summary(aov_observed_irr_nifH)
```
#### Significance in observed

```{r}
aov_observed_irr_nifH <- aov(Observed ~ Plot/Site, meta_nifH)
summary(aov_observed_irr_nifH)
```

```{r}
capture.output(aov_observed_irr_nifH,file="aov_nifH_plot_state.txt")
```


####Plot is significant but the interaction of Plot:Site is also significant so we cannot say there is actuall correlation


```{r}
aov_Chao1_irr_nifH <- aov(Chao1 ~ Plot, meta_nifH)
summary(aov_Chao1_irr_nifH)
```
#### Signifcant in chao1

```{r}
aov_Chao1_irr_nifH <- aov(Chao1 ~ Plot/Site, meta_nifH)
summary(aov_Chao1_irr_nifH)
```

```{r}
aov_Simpson_irr_nifH <- aov(Simpson ~ Plot, meta_nifH)
summary(aov_Simpson_irr_nifH)
```

```{r}
aov_Simpson_irr_nifH <- aov(Simpson ~ Plot/Site, meta_nifH)
summary(aov_Simpson_irr_nifH)
```
####All alpha diversities are significant with irrigation method but they are nested in Site so we must look within site (Huntley and Sidney) later. It is hard to prove anything in the statewide survey with univariate ANOVAs

```{r}
aov_shannon_pea_nifH <- aov(Shannon ~ Pea_variety + Site, meta_nifH)
summary(aov_shannon_pea_nifH)
```

```{r}
aov_shannon_prevcrop_nifh<-aov(Shannon ~ prev_crop, meta_nifH)
summary(aov_shannon_prevcrop_nifh)
```
```{r}
aov_shannon_prevcrop_site_nifh<-aov(Shannon ~ prev_crop/Site, meta_nifH)
summary(aov_shannon_prevcrop_site_nifh)
```


```{r}
aov_shannon_till_nifh<-aov(Shannon ~ Tillage, meta_nifH)
summary(aov_shannon_till_nifh)
```
```{r}
aov_shannon_till_site_nifh<-aov(Shannon ~ Tillage/Site, meta_nifH)
summary(aov_shannon_till_site_nifh)
```

```{r}
nifH_irr_Observ_scatter<-ggscatter(meta_nifH, x = "total_precip_irr", y = "Observed",
   rug = TRUE,
   add = "reg.line",
   color = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_irr_Shannon_scatter<-ggscatter(meta_nifH, x = "total_precip_irr", y = "Shannon",
   rug = TRUE,
   add = "reg.line",
   color = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
nifH_irr_Chao_scatter<- ggscatter(meta_nifH, x = "total_precip_irr", y = "Chao1",
   rug = TRUE,
   add = "reg.line",
   color = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

nifH_irr_InvSim_scatter<- ggscatter(meta_nifH, x = "total_precip_irr", y = "Simpson",
   rug = TRUE,
   add = "reg.line",
   color = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

alpha_nifH_irr_fig<-ggarrange(nifH_irr_Observ_scatter, nifH_irr_Shannon_scatter, 
                              nifH_irr_Chao_scatter, nifH_irr_InvSim_scatter,
                              ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_irr_fig, 
                top = text_grob("Alpha Diversity of nifH by Irrigation", size = 20))   
```



***

#Plot ordination 

####Used the following protocol from the phyloseq tutorial:
https://joey711.github.io/phyloseq/plot_ordination-examples.html


####Resources for ordination statistics
http://ordination.okstate.edu/overview.htm#Principal_Components_Analysis
Application of multivariate statistical techniques in microbial ecology:
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4769650/pdf/nihms752912.pdf
Linking multidimensional functional diversity to quantitative methods: a graphical hypothesis‐evaluation framework
https://esajournals.onlinelibrary.wiley.com/doi/full/10.1890/15-0688


###DCA Ordination 


```{r}
phynifH_ord_DCA <- ordinate(physeq_nifH_ord, "DCA", "bray")
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "Site", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  #stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  ggtitle("nifH DCA Ordination by Site and Irrigation")+
  theme_bw()
```

####Irrigation is influencing the ordination of the principle components (DCA2 is most likely comprsied of irrigation / other farm Managment)



Publish to the tiff 
```{r echo=FALSE}
tiff("nifHDCA_IRR.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "Site", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  ggtitle("nifH DCA Ordination by Site and Irrigation")+
  theme_bw()
dev.off()
```
####Will color with other farm managment to see if anytning is intresting. 

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "prev_crop", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("nifH DCA Ordination by Previous Crop and Irrigation")+
  theme_bw()

```
```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "Tillage", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values = farm_col_dark)+
  ggtitle("nifH DCA Ordination by Previous Crop and Irrigation")+
  theme_bw()

```

####These DCA plot show a distinct seperation for Tillage but not as much for previous crop

####Pea variety has no correlation or ordinaiton to bacterial community bray-curtis distance
```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "Pea_variety", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("nifH DCA Ordination by Previous Crop and Irrigation")+
  theme_bw()

```

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_DCA, color = "total_precip_irr")+
  geom_point(size = 3)+
  scale_color_gradient(low='#05D9F6', high='#5011D1')+
  ggtitle("nifH NMDS Ordination by Total Precipitation")+
  theme_bw()
```
#### There might be some Total water gradient effect in the DCA plot 

####DCA is good but we can also look in nonmetric multidimensional scaling

***Contrast between DCA and NMDS***

>DCA and NMDS are the two most popular methods for indirect gradient analysis. The reason they have remained side-by-side for so long is because, in part, they have different strengths and weaknesses...  Some of the issues are relatively minor: for example, computation time is rarely an important consideration, except for the hugest data sets. Some issues are not entirely resolved: the degree to which noise affects NMDS, and the degree to which NMDS finds local rather than global options still need to be determined ... Since NMDS is a distance-based method, all information about species identities is hidden once the distance matrix is created. For many, this is the biggest disadvantage of NMDS... perhaps the biggest difference between the two methods: DCA is based on an underlying model of species distributions, the unimodal model, while NMDS is not. Thus, DCA is closer to a theory of community ecology. However, NMDS may be a method of choice if species composition is determined by factors other than position along a gradient: For example, the species present on islands may have more to do with vicariance biogeography and chance extinction events than with environmental preferences – and for such a system, NMDS would be a better a priori choice. As De’ath (1999) points out, there are two classes of ordination methods - ‘species composition restoration’ (e.g. NMDS) and ‘gradient analysis’ (e.g. DCA). The choice between the methods should ultimately be governed by this philosophical distinction. - http://ordination.okstate.edu/overview.htm#Principal_Components_Analysis


####NMDS might be a better choice since we have non gradient determining facotrs site and farm managment effecting the bacteria community 

***
##NMDS ordination

```{r}
phynifH_ord_NMDS <- ordinate(physeq_nifH_ord, "NMDS", "bray")
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS)

```


```{r}
phynifH_ord_NMDS
```

####After stress test run, we get a value of 0.16 which is considered good, anything below 0.2 is acceptable.

####Plot NMDS with Site 

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("nifH NMDS Ordination by Site")+
  theme_bw()
```



```{r echo=FALSE}
#export physeq OTU for network analysis and saving
nifH_trim_OTU <- as(otu_table(physeq_nifH_ord), "matrix")
ID <- rownames(nifH_trim_OTU)
nifH_trim_OTU_1 <- cbind(ID, nifH_trim_OTU)
rownames(nifH_trim_OTU_1)<-c()

write.table(nifH_trim_OTU_1, file = "nifH_trim_OTU.txt", sep = "\t", row.names = FALSE)
```


```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "Pea_variety")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("nifH NMDS Ordination by Pea Variety")+
  theme_bw()
```

#### Pea variety does not influence the microbiome compostion in NMDS as well

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("nifH NMDS Ordination by Irrigation Method")+
  #stat_ellipse(type = "norm", linetype = 2, aes(color = "Plot")) +
  theme_bw()
```
```{r}
NMDS_nifH<-plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  #ggtitle("nifH NMDS Ordination by Irrigation Method")+
  #stat_ellipse(type = "norm", linetype = 2, aes(color = "Plot")) +
  theme_bw()
```



Publish to tiff
```{r echo=FALSE}
tiff("nifhNMDS_IRR.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("nifH NMDS Ordination by Irrigation Method")+
  stat_ellipse(type = "norm", linetype = 2, aes(color = "Plot")) +
  theme_bw()
dev.off()
```
####There is again a nice spliting pattern between irrgated and dryland

####Total water added

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "total_precip_irr")+
  geom_point(size = 3)+
  scale_color_gradient(low='#05D9F6', high='#5011D1')+
  ggtitle("nifH NMDS Ordination by Total Precipitation")+
  theme_bw()
```

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "Moisture_Content")+
  geom_point(size = 3)+
  scale_color_continuous(low='#05D9F6', high='#5011D1')+
  ggtitle("nifH NMDS Ordination by Mositure Content")+
  theme_bw()
```

####Total water does not ordinate well in NMDS as compared to  DCA.

####Lets try some of the other variables like till, fallow, and previous crop.

```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS,color = "Tillage")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_dark, breaks=c("Conventional", "Culti-roller", "No_till"),
                    labels=c("Conventional", "Culti Roller", "No Till"))+
  ggtitle("nifH NMDS Ordination by Tillage")+
  theme_bw()
```


Publish to .tiff
```{r echo=FALSE}
tiff("nifhNMDS_Tillage.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS,color = "Tillage")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_dark, breaks=c("Conventional", "Culti-roller", "No_till"),
                    labels=c("Conventional", "Culti Roller", "No Till"))+
  ggtitle("nifH NMDS Ordination by Tillage")+
  theme_bw()
dev.off()
```


```{r}
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "prev_crop")+
  geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("nifH NMDS Ordination by Previous Crop")+
  theme_bw()
```


Publish to .tiff
```{r echo=FALSE}
tiff("nifhNMDS_Prev_crop.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_nifH_ord, phynifH_ord_NMDS, color = "prev_crop")+
  geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("nifH NMDS Ordination by Previous Crop")+
  theme_bw()
dev.off()
```


##Beta dispersions 
####Test the diffrences in group homogeneities. Do our farm managment factors effect the homogeneitiey of the bray curtis distance? 

####If a group (Site) in the MDS space are close but have diffrenent dispersion you could have a signifcant results when it is only a diffrence in dispersion.  


Anderson (2006)-https://www.ncbi.nlm.nih.gov/pubmed/16542252

https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.1461-0248.2006.00926.x

####Irrigation beta dispersion
```{r}
nifH_bray<-distance(physeq_nifH_ord, method = "bray")
disp.plot <- betadisper(nifH_bray, meta2$Plot)
permutest(disp.plot, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp.plot)
```
```{r}
plot(disp.plot, hull = FALSE, ellipse = TRUE)
```


```{r}
disp.Till <- betadisper(distance(physeq_nifH_ord, method = "bray"), meta2$Tillage)
permutest(disp.Till, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp.Till)
```

```{r}
plot(disp.Till, hull = FALSE, ellipse = TRUE)
```

####Tillage (Conventional and Cuti-Roller) vs NO till are spliting
```{r}
disp.prev_crop <- betadisper(distance(physeq_nifH_ord, method = "bray"), meta2$prev_crop)
permutest(disp.prev_crop, pairwise=TRUE, permutations=1000)
```

```{r}
boxplot(disp.prev_crop)
```
```{r}
plot(disp.prev_crop, hull = FALSE, ellipse = TRUE)
```


```{r}
TukeyHSD(disp.prev_crop)

```
```{r}
disp.site.nifH <- betadisper(distance(physeq_nifH_ord, method = "bray"), meta2$Site)
permutest(disp.site.nifH, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp.site.nifH)
```
```{r}
nifH_dispersion_site<-data.frame(Distance_to_centroid=disp.site.nifH$distances, Site=disp.site.nifH$group)
ggboxplot(nifH_dispersion_site, x = "Site", y = "Distance_to_centroid",
   rug = TRUE,  legend = "none",
   fill = "Site", ylab = "Distance to Centroid", title = "Beta Dispersion of nifH Bray-Curtis",
   palette = farm_col_paired)+
   rotate_x_text(45, size = 10)
```

Publish to .tiff
```{r echo=FALSE}
tiff("nifH_dispersion_site.tiff", width = 6, height = 4, units = 'in', res = 600)
ggboxplot(nifH_dispersion_site, x = "Site", y = "Distance_to_centroid",
   rug = TRUE,  legend = "none",
   fill = "Site", ylab = "Distance to Centroid", title = "Beta Dispersion of nifH Bray-Curtis",
   palette = farm_col_paired)+
   rotate_x_text(45, size = 10)
dev.off()
```

```{r}
plot(disp.site.nifH, hull = FALSE, ellipse = TRUE)
```

```{r}
TukeyHSD(disp.site.nifH)
```

####The results from the beta dispersion show that we have a significant difference in the heterogeneity of our sites due to each of the farm management factors. We see that there are sites that do not have significant differences and others that do. Beta dispersion cannot except models so we cannot detect if the differences are due to nestedness (prev_crop/Site). 

####Due to the design of the experiment it will be hard to determine if the farm management practices are responsible for the variation in bacterial population. 

***
##PERMANOVA (adoins)

####We will test the significance of the farm management using the permutated-mulitvariate-ANOVA function in vegan called adonis. Adonis can test models and nestedness though the above beta dispersion test showed that most of the significance is due to the dispersion we cannot say much. But we can show we have the location effect.  

```{r}
adonis(distance(physeq_nifH_ord, method = "bray")
       ~Plot*prev_crop*Tillage*Pea_variety, data = meta2, permutations = 1000)
```

```{r}
adonis(distance(physeq_nifH_ord, method = "bray") 
       ~(Plot*prev_crop*Tillage*Pea_variety)/Site, data = meta2, permutations = 1000)
```
####Data is nested within Site (Location effect) so the significance in the bray-curtis dissimilarity with respect to plot is not significant with the data nested due to the lack of reproduction of conditions at each plot. 


####Since there is issues with doing permutated anova over multivariate data lets try to fit the chemical and farm management data the NMDS orientation space using the envfit function in vegan 

***
#Model Selection

***

##ENVFIT

####Envfit does not like single variable values so we remove them 
```{r}
meta3<-meta2[,-c(3,4,10,11,27,29,35,38,42,46)]
```
####Will remove Site categories like elevation, lat, long etc that do not differentiate between site we can call these all geographical factors as they do not change between sites. 
```{r}

meta3<-meta3[,-c(2,11:13)]
```

####Model fitting will be biased by chemical outliers that are in some plots the best way to avoid this is to determine the outliers (See chemical_analysis.Rmd) and remove the whole variable since functions ENVFIT and BIOENV will remove it if there are any n/a values. 

####Removing Sulfate_Sulfur, Boron, Molybdenum, Potassium, Vanadium, Chromium and Sodium (From chemical_analysis.rmd)
```{r}

meta3<-meta3[,-c(16,18,21,29,31)]
```

```{r}
envfitnifH <- envfit(phynifH_ord_NMDS , meta3, na.rm = TRUE, permu= 10000) 
envfitnifH
```
write to table

```{r echo=FALSE}
envfit_nifH <- data.frame((envfitnifH$vectors)$arrows, (envfitnifH$vectors)$r, (envfitnifH$vectors)$pvals )
write.table(envfit_nifH, file = "envfit_nifH.txt", sep = "\t", quote = FALSE, row.names = T)
```

####The envfit function allows us to see the correlation of our environmental vectors to the bray-curtis species dissimilarity matrix in NMDS space. This is a loose correlation to real linear correlation but it can tell us how the NMDS orientation is being driven. 

####Try a quick plot with base r and vegan for the vectors 

```{r}
plot(phynifH_ord_NMDS, display = "sites")
plot(envfitnifH, p.max = 0.001 )
```

####Organic matter is resposible for 54% of the variance 



***
#Model Selection

##Bioenv
#####Bioenv is an iterative procedure  that links enviromental variables to community strucutre by seeking the best subset of enviromental variables that explains community strucutre 

***
###Info:
###BIOENV
"The function calculates a community dissimilarity matrix using vegdist. Then it selects all possible subsets of environmental variables, scales the variables, and calculates Euclidean distances for this subset using dist. The function finds the correlation between community dissimilarities and environmental distances, and for each size of subsets, saves the best result. There are 2^p-1 subsets of p variables, and an exhaustive search may take a very, very, very long time (parameter upto offers a partial relief)."

###Mantel test 
"Mantel statistic is simply a correlation between entries of two dissimilarity matrices (some use cross products, but these are linearly related). However, the significance cannot be directly assessed, because there are N(N-1)/2 entries for just N observations. Mantel developed asymptotic test, but here we use permutations of N rows and columns of dissimilarity matrix."


***

```{r}
OTU_nifH_trim<- as(otu_table(physeq_nifH_ord ), "matrix")
```



```{r}
#Transpose the data to have sample names on rows
abund_tablenifH<-t(OTU_nifH_trim)

nrow(abund_tablenifH)
```



```{r}
setdiff(rownames(meta3), rownames(abund_tablenifH))
```
####Our meta data and sample data match with 0 diffrence in rownames


####Will use parallel processing to speed up calculations 

```{r}
#First detect amount of cores avalible 
detectCores()
```

```{r}
#get bray-curtis distance
abund_distnifH<-vegdist(abund_tablenifH, method = "bray")
#make bioenv model against whole meta table with ".", and use gower metric to measure distance in order to incroprate the factor variables. Model will be used up to 7 vriables in final model. parelle processing on 8 cores
#nifH.bioenv <- bioenv(abund_distnifH ~ ., meta3, index = "bray", method = "pearson",
 #                  metric = "gower", upto = 7, parallel = 10)

#summary(nifH.bioenv)
```


```{r}
#nifH.bioenvdist<-bioenvdist(nifH.bioenv, which = "best")
#mantel(nifH.bioenvdist, abund_distnifH)
```


```{r}
#nifH.bioenv$whichbest
```

####The best model from the inital BioEnv model selection shows that the Site explains 59% of the variation in the bray-curitis distance. But the best model explains 63% of the variation when Organic Matter and nitritie and nitrate are added in. 


####Try BioENV without site, this will favor farm managment variables since they are nested within. 

####Remove site from meta table
```{r}
meta4<-meta3[,-c(1)]
```

####Rerun BioEnv

```{r}
#nifH.bioenv.site.na <- bioenv(abund_distnifH ~ ., meta4, index = "bray", 
 #                            method = "pearson", metric = "gower", upto = 7, parallel = 10)

#summary(nifH.bioenv.site.na)
```

```{r}
#nifH.bioenvdist.site.na<-bioenvdist(nifH.bioenv.site.na, which = "best")
#mantel(nifH.bioenvdist.site.na, abund_distnifH)
```

```{r}
#nifH.bioenv.site.na$whichbest
```
####When Site is removed from the model selection we can see that there is still a bias for the Farm managment variables because they are nested with the site factor. But we do see more come out to build a bigger model. With Tillage + prev_crop + Organic_Matter + Nitrate_Nitrite + Ammonia + Av_Potassium + Manganese + Zinc. 
<br />

###Bioenv with chem data only

```{r}
#nifH.bioenv.chem <- bioenv(abund_tablenifH ~ Organic_Matter + Moisture_Content + 
 #                              Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium + 
  #                              pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium +
   #                             Manganese + Nickel + Phosphorus + Sulfur + Zinc, meta3, 
    #                          index = "bray", method = "pearson", metric = "gower",
     #                         upto = 7, parallel = 10)

#summary(nifH.bioenv.chem)
```


```{r}
#nifH.bioenvdist.chem<-bioenvdist(nifH.bioenv.chem, which = "best")
#mantel(nifH.bioenvdist.chem, abund_distnifH)
```

```{r}
#nifH.bioenv.chem$whichbest
```

####The fourth model Organic Matter, Nitrate, Phosphorus and Zinc is the best explaing 56% of the variance. Which is the same as before without the location variables. 



***
##CCA/ordistep model selection
####CCA model selection uses a procedure to take the a constrained distance ordination with the complete model and compare it with a unconstrainted model. The model starts with no variables then adds variables that make the best model. These models can then be plotted against the same ordination space as vectors.

####Ordistep use Akaike information criterion (AIC) which is a estimator of relative quality of the models. AIC is relative to models you are comparing when you compare two models the one with the lower AIC is favored.  

```{r}
m1_nifH <- cca(abund_tablenifH ~ ., meta3)
m0_nifH <- cca(abund_tablenifH ~ 1, meta3)
m1_nifH
m0_nifH
```


####Ordistep

```{r results="hide"}
model_nifH <-ordistep(m0_nifH, scope=formula(m1_nifH))
```

```{r}
model_nifH$anova
```

####Everytime a varaible is added the AIC is lowered favoring the new model. This goes till it stops. 
####cca without site
```{r}
m1_nifH_site_na <- cca(abund_tablenifH ~ ., meta4)
m0_nifH_site_na <- cca(abund_tablenifH ~ 1, meta4)
m1_nifH_site_na
m0_nifH_site_na
```


####Ordistep

```{r results="hide"}
model_nifH_site_na <-ordistep(m0_nifH_site_na, scope=formula(m1_nifH_site_na))
```

```{r}
model_nifH_site_na$anova
```



```{r}

m1_nifH_cca_chem <- cca(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc , meta3)
m0_nifH_cca_chem <- cca(abund_tablenifH ~ 1, meta3)
m1_nifH_cca_chem
m0_nifH_cca_chem
```

```{r results="hide"}
model_nifH_cca_chem <-ordistep(m0_nifH_cca_chem, scope=formula(m1_nifH_cca_chem))
```

```{r}
model_nifH_cca_chem$anova

```

####RDA is a linear cca 
```{r}
m1_nifH_rda <- rda(abund_tablenifH ~ ., meta3)
m0_nifH_rda <- rda(abund_tablenifH ~ 1, meta3)
m1_nifH_rda
m0_nifH_rda
```

```{r}
plot(m1_nifH_rda)
```


```{r results="hide"}
model_rda_nifH <-ordiR2step(m0_nifH_rda, scope=formula(m1_nifH_rda))
```

```{r}
model_rda_nifH$anova
```
####Only site appears in the complete RDA model. This is a liner based method and might not work well with our data. 


####Chemistry only RDA model 
```{r}

m1_nifH_rda_chem <- rda(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc , meta3)
m0_nifH_rda_chem <- rda(abund_tablenifH ~ 1, meta3)
m1_nifH_rda_chem
m0_nifH_rda_chem
```

```{r}
plot(m1_nifH_rda_chem)
```



```{r results="hide"}
model_rda_chem_nifH <-ordiR2step(m0_nifH_rda_chem, scope=formula(m1_nifH_rda_chem))
```

```{r}
model_rda_chem_nifH$anova
```
####Our RDA chem model can explain 30% of the variance in the bacterial community. 

***



###CAP Ordination model building

####canonical analysis of principal coordinates (CAP) is similar to RDA but allows for non-euclidian dissimilarity like Bray-Curtis which we have been using. 

https://esajournals.onlinelibrary.wiley.com/doi/epdf/10.1890/0012-9658%282003%29084%5B0511%3ACAOPCA%5D2.0.CO%3B2

###Guide for the CAP Ordination 

####https://quantpalaeo.wordpress.com/2014/04/14/variance-inflation-factors-and-ordination-model-selection/

####If the VIF of a predictor is high, it indicates that that predictor is highly correlated with other predictors, it contains little or no unique information, and there is redundancy in the set of predictors.

####STEPS
    1)Generate a constrained ordination with all available predictors.
    2)Calculate the VIF of each variable.
    3)If any variable has a VIF over a threshold (typically 10), drop the variable with the highest VIF
    4)Repeat until all remaining variables have a VIF below the threshold.

```{r}
m1_nifH_cap_chem<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc , data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem)
```

```{r}
vif.cca(m1_nifH_cap_chem)
```
####Removing Sulfur

```{r}
m1_nifH_cap_chem_1<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Zinc , data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_1)
```

```{r}
vif.cca(m1_nifH_cap_chem_1)
```
####Removing Zinc
```{r}
m1_nifH_cap_chem_2<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_2)
```

```{r}
vif.cca(m1_nifH_cap_chem_2)
```
####Removing Iron

```{r}
m1_nifH_cap_chem_3<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Magnesium + Manganese + Nickel + Phosphorus, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_3)
```

```{r}
vif.cca(m1_nifH_cap_chem_3)
```
####Removing Copper

```{r}
m1_nifH_cap_chem_4<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Magnesium + Manganese + Nickel + Phosphorus, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_4)
```
```{r}
vif.cca(m1_nifH_cap_chem_4)
```
####Removing Magnesium 

```{r}
m1_nifH_cap_chem_5<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Manganese + Nickel + Phosphorus, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_5)
```


```{r}
vif.cca(m1_nifH_cap_chem_5)
```
Removing Nickel



```{r}
m1_nifH_cap_chem_6<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Cobalt + Manganese + Phosphorus, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_6)
```
```{r}
vif.cca(m1_nifH_cap_chem_6)
```
####Removing Phosphorus as final corvariant 
```{r}
m1_nifH_cap_chem_7<- capscale(abund_tablenifH ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Cobalt + Manganese, data = meta3, distance = "bray")
m0_nifH_cap_chem<- capscale(abund_distnifH ~ 1, meta3)
plot(m1_nifH_cap_chem_7)
```
```{r}
vif.cca(m1_nifH_cap_chem_7)
```
####Every variable is under 10 will proceed to model building
```{r results="hide"}
model_cap_chem_nifH <-ordiR2step(m0_nifH_cap_chem, scope=formula(m1_nifH_cap_chem_7))
```

```{r}
aov_model_cap_chem_nifH<-model_cap_chem_nifH$anova
aov_model_cap_chem_nifH
```
make table 
```{r}
capture.output(aov_model_cap_chem_nifH,file="aov_model_cap_chem_nifH.txt")
```


#Constrained Ordination 

"http://deneflab.github.io/MicrobeMiseq/demos/mothur_2_phyloseq.html#constrained_ordinations"

###CCA with selected model from Chemical CCA model 
```{r warning=FALSE}
# CCA ordinate
cca_ord_nifH <- ordinate(
    physeq = physeq_nifH_ord, 
    method = "CCA",
    distance = abund_distnifH,
    formula = ~  Organic_Matter + Nitrate_Nitrite + Av_Potassium + 
      Av_Phosphorus + Manganese + Barium + Sulfur + Magnesium  )

# CCA plot
cca_plot_nifH <- plot_ordination(
  physeq = physeq_nifH_ord, 
  ordination = cca_ord_nifH, 
    color = "Site",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_nifH_cca <- vegan::scores(cca_ord_nifH, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_nifH_cca)

#Multiply biplot by scaling multiplier
arrowmat_nifH_cca_scale<-arrowmat_nifH_cca*3

# Add labels, make a data.frame
arrowdf_nifH_cca <- data.frame(labels = rownames(arrowmat_nifH_cca_scale), arrowmat_nifH_cca_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CCA1, 
    yend = CCA2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3* CCA1, 
    y = 1.3 * CCA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cca_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_nifH_cca, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_nifH_cca, 
    show.legend = FALSE
  )+
  ggtitle("CCA plot constrained ordination of nifH with selected Chemistry Model")+
  theme_bw()
```


####RDA with selected model from Chemical RDA model 
```{r warning=FALSE}
# RDA ordinate
rda_ord_nifH <- ordinate(
    physeq = physeq_nifH_ord, 
    method = "RDA",
    distance = abund_distnifH,
    formula = ~   Av_Phosphorus + Sulfur + Magnesium + Zinc + Av_Potassium + Manganese )

# RDA plot
rda_plot_nifH <- plot_ordination(
  physeq = physeq_nifH_ord, 
  ordination = rda_ord_nifH, 
    color = "Site",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_nifH_rda <- vegan::scores(rda_ord_nifH, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_nifH_rda)

#Multiply biplot by scaling multiplier
arrowmat_nifH_rda_scale<-arrowmat_nifH_rda*700

# Add labels, make a data.frame
arrowdf_nifH_rda <- data.frame(labels = rownames(arrowmat_nifH_rda_scale), arrowmat_nifH_rda_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = RDA1, 
    yend = RDA2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3* RDA1, 
    y = 1.3 * RDA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
rda_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_nifH_rda, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_nifH_rda, 
    show.legend = FALSE
  )+
  ggtitle("RDA plot constrained ordination of nifH with selected Chemistry Model")+
  theme_bw()
```


```{r warning=FALSE}
# CAP ordinate
cap_ord_nifH <- ordinate(
    physeq = physeq_nifH_ord, 
    method = "CAP",
    distance = abund_distnifH,
    formula = ~ Organic_Matter + Barium + Av_Potassium +
      Manganese + Av_Phosphorus + Cobalt + Nitrate_Nitrite)

# CAP plot
cap_plot_nifH <- plot_ordination(
  physeq = physeq_nifH_ord, 
  ordination = cap_ord_nifH, 
    color = "Site", 
    shape = "Plot",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_nifH_cap <- vegan::scores(cap_ord_nifH, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_nifH_cap)

#Multiply biplot by scaling multiplier
arrowmat_nifH_cap_scale<-arrowmat_nifH_cap*1.9

# Add labels, make a data.frame
arrowdf_nifH_cap <- data.frame(labels = rownames(arrowmat_nifH_cap_scale), arrowmat_nifH_cap_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CAP1, 
    yend = CAP2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3 * CAP1, 
    y = 1.3 * CAP2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cap_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_nifH_cap, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_nifH_cap, 
    show.legend = FALSE
  )+
  ggtitle("CAP Plot Constrained Ordination of nifH with Selected Model")+
  theme_bw()
```

```{r echo=FALSE}
tiff("nifHCAP_chem.tiff", width = 8, height = 5, units = 'in', res = 600)
cap_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_nifH_cap, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_nifH_cap, 
    show.legend = FALSE
  )+
  ggtitle("CAP Plot Constrained Ordination of nifH with Selected Model")+
  theme_bw()
dev.off()
```


#### Fitting species to cap plot 
```{r}
m1_nifH_cap_chem_species<- capscale(abund_tablenifH~ Organic_Matter + Barium + Av_Potassium +
      Manganese + Av_Phosphorus + Cobalt + Nitrate_Nitrite, data = meta3, distance = "bray")
dims=c(1,2)
site=scores(m1_nifH_cap_chem_species,display="wa",choices=dims)
cor.min=0.9 #below this threshold, arrows will be not plotted 
#because orrelation is considered too much week
cor_sp=as.data.frame(scores(m1_nifH_cap_chem_species, dis="sp", scaling=1,choices=dims))
cor_sp$cor=with(cor_sp,sqrt(CAP1^2+CAP2^2))
cor_sp$sup=FALSE;cor_sp$sup[cor_sp$cor>=cor.min]<-TRUE
cor_sp$labels=row.names(cor_sp)
cor_sp=cor_sp[cor_sp$sup==TRUE,]
cor_sp_s1=cor_sp



```


```{r}
tax_nifH_cap<- read.delim("~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/nifH_OTU_ids_2016_fixed1.txt", row.names = 1, colClasses = c(rep('character', 8) ))
head(tax_nifH_cap)[,1:8]

#use perl scirpt to remove teh g_
tax_nifH_cap$species<- sub(".*_", "", tax_nifH_cap$species)
#use the function captilize to captilize first letter
tax_nifH_cap$species<- capitalize(tax_nifH_cap$species)

species_nifH<-merge(cor_sp_s1, tax_nifH_cap, by="row.names")


```


Replot with species
```{r warning=FALSE}
# CAP ordinate
cap_ord_nifH <- ordinate(
    physeq = physeq_nifH_ord, 
    method = "CAP",
    distance = abund_distnifH,
    formula = ~ Organic_Matter + Barium + Av_Potassium +
      Manganese + Av_Phosphorus + Cobalt + Nitrate_Nitrite)

# CAP plot
cap_plot_nifH <- plot_ordination(
  physeq = physeq_nifH_ord, 
  ordination = cap_ord_nifH, 
    color = "Site", 
    shape = "Plot",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 


# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CAP1, 
    yend = CAP2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = species)

label_map <- aes(x = 1.3 * CAP1, 
    y = 1.3 * CAP2, 
    shape = NULL, 
    color = NULL, 
    label = species)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cap_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = species_nifH, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = species_nifH, 
    show.legend = FALSE,
    fontface="italic"
  )+
  ggtitle("CAP Plot Constrained Ordination of nifH with Correlated Species")+
  theme_bw()
```
Publish to tiff
```{r echo=FALSE}
tiff("nifHCAP_species.tiff", width = 8, height = 5, units = 'in', res = 600)
cap_plot_nifH + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = species_nifH, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = species_nifH, 
    show.legend = FALSE,
    fontface="italic"
  )+
  ggtitle("CAP Plot Constrained Ordination of nifH with Correlated Species")+
  theme_bw()
dev.off()
```