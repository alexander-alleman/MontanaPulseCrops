---
title: "Montana Statewide 16s Analysis"
author: "Alexander Alleman"
date: "January 29, 2019"
output:
  pdf_document:
    df_print: kable
  word_document: default
  html_document: default
---

```{r echo=FALSE}
gsub("[[:punct:][:space:]]", "-", Sys.time())
```


```{r echo=FALSE}
getwd()
```

```{r}
set.seed(8765)
```

###Load packages
```{r warning=FALSE,message=FALSE}
library(ggplot2)
library(data.table)
library(vegan)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(ggpubr)
library(RColorBrewer)
library(ape)
library(grid)
#library(knitr)
library(ggrepel)
library(igraph)
library(Hmisc)
library(Matrix)
library(ggnetwork)
library(intergraph)
library(parallel)
library(tinytex)
library(phyloseq)
```

```{r echo=FALSE}
#library(knitr)
#opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE)
```

####Colors
```{r}
farm_col<-(c("#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"))
farm_col_dark<-brewer.pal(7, "Dark2")
farm_col_paired<-(c('#fdbf6f','#ff7f00','#b2df8a','#33a02c','#fb9a99','#e31a1c','#cab2d6','#a6cee3','#1f78b4'))
```

***
##Load OTU, Taxa, and Meta data

####Add OTU table with sample names on top and OTU names as row names 
```{r}
OTU_16s<- read.delim("~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/16s_OTUall2016_fixed.txt", row.names = 1)
head(OTU_16s)[,1:10]
```

```{r}
OTU_16s <- subset(OTU_16s, select = -c(102))
```


####Add taxa data from Mr. DNA column seperated into 8 columns down to the strain level. This taxa assignment was done by Mr. DNA and assigned from the database greengenes. 
```{r}
tax_16s<- read.delim("~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/16s_OTU_ids_2016_fixed.txt", row.names = 1)
head(tax_16s)[,1:8]
```

####Meta data set has be placed together from all the spring and summer data with excel
```{r}
meta<- read.delim("~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/all_metadata_summer.csv", row.names = 1, na.strings = "NA", sep = ",",
                  colClasses = c(rep('factor', 7), rep('numeric', 3), rep('factor', 4), 'numeric',
                                 rep('factor', 3), rep('numeric', 28) ) )
head(meta)[,1:5]
```


####Removed all Havre for analysis 
```{r}
meta2 <- meta[-c(19:48),]
sapply(meta2, class)
```

#### Convert to matrix 

```{r}
OTU_16s_m<-as.matrix(OTU_16s)
tax_16s_m<-as.matrix(tax_16s)
meta_m<-as.matrix(meta2)

class(OTU_16s_m)
class(tax_16s_m)
class(meta_m)

```


####Make phyloseq object
```{r}
OTU16s = otu_table(OTU_16s_m, taxa_are_rows = TRUE)
TAX16s = tax_table(tax_16s_m)

physeq_16s = phyloseq(OTU16s, TAX16s)
```


####Get physeq info
```{r}
physeq_16s
```

###Add meta data to both phyoseq 

```{r}
meta_phy <- sample_data(meta2)
sample_names(meta_phy)
```

```{r}
physeq_16s<-merge_phyloseq(physeq_16s, meta_phy)
physeq_16s
```
####Make sure the samples match 54-54, 36023-36023, and 45 measured variables

####Rarefiy data
```{r}
physeq_16s<-rarefy_even_depth(physeq_16s)
physeq_16s
```


***
#Trim data
###Trim data to exclude OTUs that are not in any samples 
http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html#taxa-total-counts-histogram

```{r}
tdt_16s = data.table(tax_table(physeq_16s),
                 TotalCounts = taxa_sums(physeq_16s),
                 OTU = taxa_names(physeq_16s))
ggplot(tdt_16s, aes(TotalCounts)) + 
  geom_histogram() + 
  ggtitle("Histogram of Total Counts 16s")
```

#### How many OTUS have low count (Rare)?
```{r}
tdt_16s[(TotalCounts <= 0), .N]#zero count
tdt_16s[(TotalCounts <= 1), .N]#single count
tdt_16s[(TotalCounts <= 2), .N]#double count
```

#####We have many OTUS with no counts or less than two we will trim the data to remove these OTUS. But how much to remove? 

```{r}
# taxa cumulative sum
taxcumsum_16s = tdt_16s[, .N, by = TotalCounts]
setkey(taxcumsum_16s, TotalCounts)
taxcumsum_16s[, CumSum := cumsum(N)]
# Define the plot
pCumSum_16s = ggplot(taxcumsum_16s, aes(TotalCounts, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Minimum Total Counts") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold (16s)")
pCumSum_16s
```
####Zoom-in find threshold

```{r}
pCumSum_16s + xlim(0, 100)
```
###Sort by prevlance (number of times an OTU is observed at least once)

melt function for taxa prevelance filtering
http://evomics.org/wp-content/uploads/2016/01/phyloseq-Lab-01-Answers.html#taxa-total-counts-histogram

fast_melt function
```{r echo=FALSE}
# Define some functions for quick taxa summary

fast_melt = function(physeq,
                     includeSampleVars = character(),
                     omitZero = FALSE){
  require("phyloseq")
  require("data.table")
  # supports "naked" otu_table as `physeq` input.
  otutab = as(otu_table(physeq), "matrix")
  if(!taxa_are_rows(physeq)){otutab <- t(otutab)}
  otudt = data.table(otutab, keep.rownames = TRUE)
  setnames(otudt, "rn", "TaxaID")
  # Enforce character TaxaID key
  otudt[, TaxaIDchar := as.character(TaxaID)]
  otudt[, TaxaID := NULL]
  setnames(otudt, "TaxaIDchar", "TaxaID")
  # Melt count table
  mdt = melt.data.table(otudt, 
                        id.vars = "TaxaID",
                        variable.name = "SampleID",
                        value.name = "count")
  if(omitZero){
    # Omit zeroes and negative numbers
    mdt <- mdt[count > 0]
  }
  # Omit NAs
  mdt <- mdt[!is.na(count)]
  # Calculate relative abundance
  mdt[, RelativeAbundance := count / sum(count), by = SampleID]
  if(!is.null(tax_table(physeq, errorIfNULL = FALSE))){
    # If there is a tax_table, join with it. Otherwise, skip this join.
    taxdt = data.table(as(tax_table(physeq, errorIfNULL = TRUE), "matrix"), keep.rownames = TRUE)
    setnames(taxdt, "rn", "TaxaID")
    # Enforce character TaxaID key
    taxdt[, TaxaIDchar := as.character(TaxaID)]
    taxdt[, TaxaID := NULL]
    setnames(taxdt, "TaxaIDchar", "TaxaID")
    # Join with tax table
    setkey(taxdt, "TaxaID")
    setkey(mdt, "TaxaID")
    mdt <- taxdt[mdt]
  }
  # includeSampleVars = c("DaysSinceExperimentStart", "SampleType")
  # includeSampleVars = character()
  # includeSampleVars = c()
  # includeSampleVars = c("aksjdflkas") 
  wh.svars = which(sample_variables(physeq) %in% includeSampleVars)
  if( length(wh.svars) > 0 ){
    # Only attempt to include sample variables if there is at least one present in object
    sdf = as(sample_data(physeq), "data.frame")[, wh.svars, drop = FALSE]
    sdt = data.table(sdf, keep.rownames = TRUE)
    setnames(sdt, "rn", "SampleID")
    # Join with long table
    setkey(sdt, "SampleID")
    setkey(mdt, "SampleID")
    mdt <- sdt[mdt]
  }
  setkey(mdt, "TaxaID")
  return(mdt)
}

summarize_taxa = function(physeq, Rank, GroupBy = NULL){
  require("phyloseq")
  require("data.table")
  Rank <- Rank[1]
  if(!Rank %in% rank_names(physeq)){
    message("The argument to `Rank` was:\n", Rank,
            "\nBut it was not found among taxonomic ranks:\n",
            paste0(rank_names(physeq), collapse = ", "), "\n",
            "Please check the list shown above and try again.")
  }
  if(!is.null(GroupBy)){
    GroupBy <- GroupBy[1]
    if(!GroupBy %in% sample_variables(physeq)){
      message("The argument to `GroupBy` was:\n", GroupBy,
              "\nBut it was not found among sample variables:\n",
              paste0(sample_variables(physeq), collapse = ", "), "\n",
              "Please check the list shown above and try again.")
    }
  }
  # Start with fast melt
  mdt = fast_melt(physeq)
  if(!is.null(GroupBy)){
    # Add the variable indicated in `GroupBy`, if provided.
    sdt = data.table(SampleID = sample_names(physeq),
                     var1 = get_variable(physeq, GroupBy))
    setnames(sdt, "var1", GroupBy)
    # Join
    setkey(sdt, SampleID)
    setkey(mdt, SampleID)
    mdt <- sdt[mdt]
  }
  # Summarize
  if(!is.null(GroupBy)){
    summarydt = mdt[, list(meanRA = mean(RelativeAbundance),
                           sdRA = sd(RelativeAbundance),
                           minRA = min(RelativeAbundance),
                           maxRA = max(RelativeAbundance)),
                    by = c(Rank, GroupBy)]
  } else {
    Nsamples = nsamples(physeq)
    # No GroupBy argument, can be more precise with the mean, sd, etc.
    summarydt = mdt[, list(meanRA = sum(RelativeAbundance) / Nsamples,
                           sdRA = sd(c(RelativeAbundance, numeric(Nsamples - .N))),
                           minRA = ifelse(test = .N < Nsamples,
                                          yes = 0L, 
                                          no = min(RelativeAbundance)),
                           maxRA = max(RelativeAbundance)),
                    by = c(Rank)]
  }
  return(summarydt)
}

plot_taxa_summary = function(physeq, Rank, GroupBy = NULL){
  require("phyloseq")
  require("data.table")
  require("ggplot2")
  # Get taxa summary table 
  dt1 = summarize_taxa(physeq, Rank = Rank, GroupBy = GroupBy)
  # Set factor appropriately for plotting
  RankCol = which(colnames(dt1) == Rank)
  setorder(dt1, -meanRA)
  dt1[, RankFac := factor(dt1[[Rank]], 
                          levels = rev(dt1[[Rank]]))]
  dt1[, ebarMax := max(c(0, min(meanRA + sdRA))), by = eval(Rank)]
  dt1[, ebarMin := max(c(0, min(meanRA - sdRA))), by = eval(Rank)]
  # Set zeroes to one-tenth the smallest value
  ebarMinFloor = dt1[(ebarMin > 0), min(ebarMin)]
  ebarMinFloor <- ebarMinFloor / 10
  dt1[(ebarMin == 0), ebarMin := ebarMinFloor]
  
  pRank = ggplot(dt1, aes(x = meanRA, y = RankFac)) +
    scale_x_log10() +
    xlab("Mean Relative Abundance") +
    ylab(Rank) +
    theme_bw()
  if(!is.null(GroupBy)){
    # pRank <- pRank + facet_wrap(facets = as.formula(paste("~", GroupBy)))
    pRank <- pRank + geom_point(mapping = aes_string(colour = GroupBy),
                                size = 5)
  } else {
    # Don't include error bars for faceted version
    pRank <- pRank + geom_errorbarh(aes(xmax = ebarMax,
                                        xmin = ebarMin))
  }
  return(pRank)
}
```

```{r}
mdt_16s = fast_melt(physeq_16s)
prevdt16s = mdt_16s[, list(Prevalence = sum(count > 0), 
                    TotalCounts = sum(count)),
             by = TaxaID]
```

```{r}
ggplot(prevdt16s, aes(Prevalence)) + 
  geom_histogram() + 
  ggtitle("Histogram of Taxa Prevalence 16s")
```
```{r}
# How many OTUS have low prevelance (Rare)?
prevdt16s[(Prevalence <= 0), .N]#zero 
prevdt16s[(Prevalence <= 1), .N]#single 
prevdt16s[(Prevalence <= 2), .N]#double 
prevdt16s[(Prevalence >= 54), .N]#how many OTUs are in all samples
```

####So our samples have low abundance and low prevelance 
####Zoomed in scater plots for prevalence
```{r}
prevcumsum16s = prevdt16s[, .N, by = Prevalence]
setkey(prevcumsum16s, Prevalence)
prevcumsum16s[, CumSum := cumsum(N)]
pPrevCumSum = ggplot(prevcumsum16s, aes(Prevalence, CumSum)) + 
  geom_point() +
  xlab("Filtering Threshold, Prevalence") +
  ylab("OTUs Filtered") +
  ggtitle("OTUs that would be filtered vs. the minimum count threshold")
pPrevCumSum
```

####Prevalence vs total count scatter plot
```{r}
ggplot(prevdt16s, aes(Prevalence, TotalCounts)) + 
  geom_point(size = 2, alpha = 0.50) + 
  scale_y_log10()
```

#####So we have a good distrubution of low abundnace and low prevlance OTUS and high abundance and high prevelance OTUs

***
##Trimming
####Remove less than triplets in data  and prevlant in 20% of the sample


```{r}
physeq_16s_trim = filter_taxa(physeq_16s, function(x) sum(x > 3) > (0.2*length(x)), TRUE)
physeq_16s_trim
```
#### We have removed the majorty of the low abundance data with a remaining 4200 taxa which make the data analysis much more managable.

***
#Analysis

***
##Alpha Analysis
###Bar plots 

####Batch all phylum that do not have more than 5% abundance in the total abundance and group together and call "<5% abundance"
```{r}
physeq_16s_ord_1 = transform_sample_counts(physeq_16s_trim, function(x) x / sum(x) )
physeq_16s_ord_phylum <- tax_glom(physeq_16s_ord_1, "phylum")
data_16s_phylum <- psmelt(physeq_16s_ord_phylum)
data_16s_phylum$phylum<-as.character(data_16s_phylum$phylum)
data_16s_phylum$phylum[data_16s_phylum$Abundance<0.05]<-"<5% abdund"
count <- length(unique(data_16s_phylum$phylum))
count
unique(data_16s_phylum$phylum)
```
#### We have 9 Phylum that are more the 5% of the total abundance in all samples this simplifies the plot to a readable format

```{r}
ggplot(data = data_16s_phylum, aes(x = Site, y = Abundance, fill = phylum))+
geom_bar(aes(fill = phylum), stat = "identity",  position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   #values=c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#984ea3','#e31a1c','#fdbf6f','#ff7f00','#cab2d6'),
                  values = c('#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9'),
                   breaks = c( "<5% abdund" , "p__acidobacteria", "p__actinobacteria","p__bacteroidetes", "p__chloroflexi",  "p__cyanobacteria", "p__firmicutes" , "p__gemmatimonadetes", "p__nitrospirae", "p__planctomycetes", "p__proteobacteria", "p__verrucomicrobia"),
                   labels = c("<5% Abundance", "Acidobacteria", "Actinobacteria", "Bacteroidetes", "Chloroflexi", "Cyanobacteria", "Firmicutes", "Gemmatimonadetes", "Nitrospirae", "Planctomycetes", "Proteobacteria", "Verrucomicrobia"),
              guide = guide_legend(reverse = FALSE)
               )+
ggtitle("16s Phylum Relative Abundance by Site")+
ylab("Relative Abundance")+
#scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", "Huntley Irrigated", "Kalispell", #
  #"Moccasin", "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(), panel.background = element_blank())
```
#### There is a nice distrubution of Taxa among sites with some phyla being present or most likely in the <5% abundance portion. The taxa are dominated by Acintobacteria and Proteobacteria as expected 


Publish figure as a tiff
```{r}
tiff("16s_barplot.tiff", width = 6, height = 4, units = 'in', res = 600)
ggplot(data = data_16s_phylum, aes(x = Site, y = Abundance, fill = phylum))+
geom_bar(aes(fill = phylum), stat = "identity",  position = "stack", show.legend = TRUE)+
scale_fill_manual(name = "Phylum", 
                   values=c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#984ea3','#e31a1c','#fdbf6f','#ff7f00','#cab2d6'),
                   breaks = c( "<5% abdund" , "p__acidobacteria", "p__actinobacteria","p__bacteroidetes", "p__chloroflexi",  "p__cyanobacteria", "p__firmicutes" , "p__gemmatimonadetes", "p__nitrospirae", "p__planctomycetes", "p__proteobacteria", "p__verrucomicrobia"),
                   labels = c("<5% Abundance", "Acidobacteria", "Actinobacteria", "Bacteroidetes", "Chloroflexi", "Cyanobacteria", "Firmicutes", "Gemmatimonadetes", "Nitrospirae", "Planctomycetes", "Proteobacteria", "Verrucomicrobia"),
              guide = guide_legend(reverse = FALSE)
               )+
ggtitle("16s Phylum Relative Abundance by Site")+
ylab("Relative Abundance")+
scale_x_discrete(labels = c("Conrad", "Corvallis", "Huntley Dryland", "Huntley Irrigated", "Kalispell", "Moccasin", "Sidney Dryland", "Sidney Irrigated", "Richland"))+
theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(), panel.background = element_blank())
dev.off()
```


##Alpha diversity metrics 
####Use phyloseq internal packages to calculate the alpha diversity 
```{r}
plot_richness(physeq_16s_trim)
```


####Simplify to just observed and Chao1 and Shannon

```{r}
plot_richness(physeq_16s_trim, measures = c("Observed","Chao1", "Shannon"), color = "Site")
```

####Make a table of the alpha and write table to folder
```{r echo=FALSE}
rich_16s<-estimate_richness(physeq_16s_trim, split = TRUE)
write.table(rich_16s, file = "alpha_16s_statewide.text", sep = "\t")
head(rich_16s)
```




####Just make a shannon table for further analysis
```{r}
statewide_16s_shannon<-estimate_richness(physeq_16s_trim, split = TRUE, measures = "Shannon")

write.table(statewide_16s_shannon, file = "statewide_16s_shannon.text", sep = "\t")

head(statewide_16s_shannon)
```
####Plot Shannon diversity boxplot using ggpubr 

```{r}
#make new DF with just shannon and site 
statewide_16s_shannon$Site<-meta2$Site

#colors


#use ggpubr for plot 
ggboxplot(statewide_16s_shannon, x = "Site", y = "Shannon",
   add = "mean", rug = TRUE,
   fill = "Site",
   title = "16s Shannon Diversity by Site", palette = farm_col_paired, legend = "right")+
  stat_compare_means(label.y = 7.4,  p.adjust.method = "bonferroni")+
  rotate_x_text()
```
#### We see there is a signficant diffrence between sites using the Kruskal-Wallis test. From the above graph we see the plots look like normal distrubution with shannon but lets check if the data is normal in all alpha metrics. 

####Used the following protocol 
https://rpubs.com/dillmcfarlan/R_microbiotaSOP
```{r}
#Create 2x2 plot environment so that we can see all 4 metrics at once. 
par(mfrow = c(3, 3))

#Then plot each metric.
hist(rich_16s$Observed, main="Observed OTUs", xlab="", breaks=10)
hist(rich_16s$Shannon, main="Shannon diversity", xlab="", breaks=10)
hist(rich_16s$Simpson, main="Simpson diversity", xlab="", breaks=10)
hist(rich_16s$Chao1, main="Chao richness", xlab="", breaks=15)
hist(rich_16s$ACE, main="ACE richness", xlab="", breaks=15)
hist(rich_16s$InvSimpson, main="Inverse Simpson", xlab="", breaks=15)
```
####Test for normalcy using the shapiro test. The null hypothesis for this test is that the data are normally distributed, if the p-value is greater than 0.05, then the null hypothesis is not rejected.
```{r}
shapiro.test(rich_16s$Observed)
shapiro.test(rich_16s$Shannon)
shapiro.test(rich_16s$InvSimpson)
shapiro.test(rich_16s$Chao1)
shapiro.test(rich_16s$ACE)
shapiro.test(rich_16s$InvSimpson)
```

#### So we cannnot reject the null for InvSimpson CHao1 and Ace because the are all normal and we can use the standard ANOVA and t-test to test our hypothesis. The Shannon index is just barley not normal but that just means we use other test like the above Kruskal-Wallis and Wilcoxon Rank sum to test the hypotheis angainst shannon. But since it is so close to normallcy we will run anova with all.

#### Merege the meta data with the richness data and add back to the phyloseq data
```{r}
#First merge data sets with meta2 
meta2$sample_names<-rownames(meta2)
rich_16s$sample_names<-rownames(rich_16s)
meta_16s<-merge(meta2, rich_16s, by = "sample_names")
rownames(meta_16s)<-meta_16s$sample_names
meta_16s<-meta_16s[,-1]
head(meta_16s)
```
```{r}
mean(meta_16s$Observed)
```
```{r}
ggplot(meta_16s, aes( x= Site, y = Shannon, fill = Site)) +
  geom_boxplot(position = position_dodge(0.1),fill = farm_col_paired) +
  #geom_jitter(size = 0.5, alpha = 0.8)+
  theme_bw()
```


```{r}
shannon_16s<-ggboxplot(meta_16s, x = "Site", y = "Shannon",
   rug = TRUE,
   fill = "Site", xlab = " ", width = 0.4, title = "16s",
   palette = farm_col_paired,
   legend = "right"
   )+
  rremove("x.text")
  
```

```{r}
tiff("shannon_16s.tiff", width = 5, height = 8, units = 'in', res = 600)
shannon_16s
  
dev.off()
```

####Make multiple grid plot with observed, shannon simpson and chao1 diveristy 
```{r}
#colors

#use ggpubr for plot 
s16_Observ<-ggboxplot(meta_16s, x = "Site", y = "Observed",
   rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
s16_Shannon<-ggboxplot(meta_16s, x = "Site", y = "Shannon",
   rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
s16_Chao<- ggboxplot(meta_16s, x = "Site", y = "Chao1",
    rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

s16_InvSim<- ggboxplot(meta_16s, x = "Site", y = "InvSimpson",
   rug = TRUE,
   fill = "Site", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

alpha_nifH_fig<-ggarrange(s16_Observ, s16_Shannon, s16_Chao, s16_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_fig, top = text_grob("Alpha Diversity of 16s", size = 20))   
```
```{r}
s16_Observ_stats<-ggplot_build(s16_Observ)
s16_Observ_stats$data
```

```{r}
s16_shannon_stats<-ggplot_build(s16_Shannon)
s16_shannon_stats$data
```
Save to .tiff
```{r echo=FALSE}
tiff("aDiv_16s.tiff", width = 8, height = 4.5, units = 'in', res = 600)
alpha_nifH_fig<-ggarrange(s16_Observ, s16_Shannon, s16_Chao, s16_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_nifH_fig, top = text_grob("Alpha Diversity of 16s", size = 20))   
dev.off()

```
####Explination of alpha diversity metrics:
***Observed***- total observed OTUs
***Chao1***- estimate diversity and	assumes	that	the	number	of	observations	for	a	taxa	has	a	Poisson
distribution	and	corrects	for	variance
***Shannon***- # of OTUs (richness) scaled to the evenness 
***Simpson***- scale of dominace probabilty of any two indviduals drawn at random beloging to the same species 

####Use ANOVA on alpha diversity metrics for main variables

####Shannon first 
```{r}
aov_shannon_site_16s <- aov(Shannon ~ Site, meta_16s)
summary(aov_shannon_site_16s)
```
Correct for multiple comparisons
```{r}
shannon_16s_site<- TukeyHSD(aov_shannon_site_16s, "Site", ordered = TRUE)
shannon_16s_site
```
not all groups have sgnificant diffrence must plot large plot with all comparios 

Write to table

```{r echo=FALSE}
shannon_16s_site_df<- as.data.frame(shannon_16s_site$Site)
write.table(shannon_16s_site_df, file = "shannon_16s_site.txt", sep = "\t", quote = FALSE, row.names = T)
```

####irrigation 

```{r}
aov_shannon_irr <- aov(Shannon ~ Plot, meta_16s)
summary(aov_shannon_irr)
```
####irrgation is not sigficant driver of alpha diversity 
####Plot Irrigation 

```{r}


#use ggpubr for plot 
s16_Observ<-ggboxplot(meta_16s, x = "Plot", y = "Observed",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
s16_Shannon<-ggboxplot(meta_16s, x = "Plot", y = "Shannon",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")
  
s16_Chao<- ggboxplot(meta_16s, x = "Plot", y = "Chao1",
    rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

s16_InvSim<- ggboxplot(meta_16s, x = "Plot", y = "Simpson",
   rug = TRUE,
   fill = "Plot", xlab = " ",
   palette = farm_col_paired)+
  rremove("x.text")

alpha_16s_irr_fig<-ggarrange(s16_Observ, s16_Shannon, s16_Chao, s16_InvSim, ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")

annotate_figure(alpha_16s_irr_fig, top = text_grob("Alpha Diversity of 16s by Plot", size = 20))   
```
####Looks like there is significance in the other diverisities to for irrgation (Dryland vs irrigated)
```{r}
aov_observed_irr <- aov(Observed ~ Plot, meta_16s)
summary(aov_observed_irr)
```
#### No diffrence in observed 
```{r}
aov_shannon_irr <- aov(Shannon ~ Plot, meta_16s)
summary(aov_shannon_irr)
```
```{r}
aov_shannon_irr_site <- aov(Shannon ~ Plot/Site, meta_16s)
summary(aov_shannon_irr_site)
```
```{r}
capture.output(aov_shannon_irr_site,file="aov_16s_plot_state.txt")
```

```{r}
aov_Chao1_irr <- aov(Chao1 ~ Plot/Site, meta_16s)
summary(aov_Chao1_irr)
```
####just signifcant in chao1

```{r}
aov_Simpson_irr <- aov(Simpson ~ Plot, meta_16s)
summary(aov_Simpson_irr)
```
####Simpson is not signficant 
####Shannon is the only metric that is signficant with irrgation but it is nested within the Site so we have location effect with the alpha. 

```{r}
aov_shannon_tillage <- aov(Shannon ~ Tillage, meta_16s)
summary(aov_shannon_tillage)
```
```{r}
aov_shannon_site_tillage <- aov(Shannon ~ Tillage/Site, meta_16s)
summary(aov_shannon_site_tillage)
```

####Lets test another important facotral variable previous crop
```{r}
aov_shannon_prevcrop <- aov(Shannon ~ prev_crop, meta_16s)
summary(aov_shannon_prevcrop)
```
```{r}
aov_shannon_prevcrop <- aov(Shannon ~ prev_crop/Site, meta_16s)
summary(aov_shannon_prevcrop)
```

####Previous crop is but most likely nested within site 
```{r}
aov_shannon_site_prevcrop <- aov(Shannon ~ Site + prev_crop + Site:prev_crop, meta_16s)
summary(aov_shannon_site_prevcrop)
```
####We see which is what we will see with most of the farm managament factors that they are nested within the site varaibles due to experimental design. 

***

#Plot ordination 
####To simplfy ordination and save time we will trim the OTUs more 
####Remove OTUs that do not show appear more than 5 times in more than 10th of the samples
https://joey711.github.io/phyloseq/plot_ordination-examples.html


```{r}
wh0 = genefilter_sample(physeq_16s_trim, filterfun_sample(function(x) x > 5), A=0.1*nsamples(physeq_16s_trim))
physeq_16s_ord = prune_taxa(wh0, physeq_16s_trim)
physeq_16s_ord
```
Transform to even sampling depth
```{r}
physeq_16s_ord = transform_sample_counts(physeq_16s_ord, function(x) 1E6 * x/sum(x))
physeq_16s_ord
```
##RDA Ordination 

```{r}
farm_col_paired<-(c('#fdbf6f','#ff7f00','#b2df8a','#33a02c','#fb9a99','#e31a1c',"black",'#cab2d6','#a6cee3','#1f78b4' ))
```

```{r}
phy16s_ord_DCA<- ordinate(physeq_16s_ord, "DCA", "bray")
plot_ordination(physeq_16s_ord, phy16s_ord_DCA, color = "Site", shape = "Plot")+
    geom_point(size = 3)+
  stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = F) +
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("16s DCA Ordination by Site and Irrigation")+
  theme_bw()

```
####Irrigation is influencing the ordination of the principle components (DCA1 is most likely comprsied of irrigation / other farm Managment)

```{r}
tiff("16sDCA_IRR.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_16s_ord, phy16s_ord_DCA, color = "Site", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  ggtitle("16s DCA Ordination by Site and Irrigation")+
  theme_bw()
dev.off()
```
####Will color with other farm managment to see if anytning is intresting. 

```{r}
phy16s_ord_DCA <- ordinate(physeq_16s_ord, "DCA", "bray")
plot_ordination(physeq_16s_ord, phy16s_ord_DCA, color = "prev_crop", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("16s DCA Ordination by Previous Crop and Irrigation")+
  theme_bw()

```
```{r}
phy16s_ord_DCA <- ordinate(physeq_16s_ord, "DCA", "bray")
plot_ordination(physeq_16s_ord, phy16s_ord_DCA, color = "Tillage", shape = "Plot")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_dark)+
  ggtitle("16s DCA Ordination by Tillage and Irrigation")+
  theme_bw()

```
####Tillage has not much patterns neither compared to previous crop. The design of the study doesn't allow us to pull apart the Farm Mangament stratagies due to the fact that many factors are overlaping (ie most Irrigated plots were prev-crop barley and most dryland plots are no till plots). 

####Pea variety has no correlation or ordnaiton to bacterial community bray-curtis distance
```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_DCA, color = "Pea_variety")+
    geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  ggtitle("16s DCA Ordination by Pea Variety")+
  theme_bw()

```

```{r echo=FALSE}
#export physeq OTU for network analysis and saving
n16s_trim_OTU <- as(otu_table(physeq_16s_ord), "matrix")
ID <- rownames(n16s_trim_OTU)
n16s_trim_OTU_1 <- cbind(ID, n16s_trim_OTU)
rownames(n16s_trim_OTU_1)<-c()
#replace 0 with blank
n16s_trim_OTU_1[n16s_trim_OTU_1 == 0] <- ""


write.table(n16s_trim_OTU_1, file = "n16s_trim_OTU.txt", sep = "\t", row.names = FALSE)
```


####CDA is good but we can also look in nonmetric multidimensional scaling

***Contrast between DCA and NMDS***

>DCA and NMDS are the two most popular methods for indirect gradient analysis. The reason they have remained side-by-side for so long is because, in part, they have different strengths and weaknesses...  Some of the issues are relatively minor: for example, computation time is rarely an important consideration, except for the hugest data sets. Some issues are not entirely resolved: the degree to which noise affects NMDS, and the degree to which NMDS finds local rather than global options still need to be determined ... Since NMDS is a distance-based method, all information about species identities is hidden once the distance matrix is created. For many, this is the biggest disadvantage of NMDS... perhaps the biggest difference between the two methods: DCA is based on an underlying model of species distributions, the unimodal model, while NMDS is not. Thus, DCA is closer to a theory of community ecology. However, NMDS may be a method of choice if species composition is determined by factors other than position along a gradient: For example, the species present on islands may have more to do with vicariance biogeography and chance extinction events than with environmental preferences – and for such a system, NMDS would be a better a priori choice. As De’ath (1999) points out, there are two classes of ordination methods - ‘species composition restoration’ (e.g. NMDS) and ‘gradient analysis’ (e.g. DCA). The choice between the methods should ultimately be governed by this philosophical distinction. - http://ordination.okstate.edu/overview.htm#Principal_Components_Analysis


####NMDS might be a better choice since we have non gradient determining facotrs site and farm managment effecting the bacteria community 


##NMDS Ordination 
```{r}
phy16s_ord_NMDS <- ordinate(physeq_16s_ord, "NMDS", "bray")
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS)

```
####Data has good ordination with NMDS must see stress to make sure the algorithum didnt force fit any ordination.

```{r}
phy16s_ord_NMDS
```

####After stress test run, we get a value of 0.07 which is considered good, anything below 0.2 is acceptable.


####Plot NMDS with Site and Irrigation 
```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  #stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  ggtitle("16s NMDS Ordination by Irrigation Method")+
  theme_bw()
```


```{r}
NMDS_16s<-plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  #stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  #ggtitle("16s NMDS Ordination by Irrigation Method")+
  theme_bw()
```



```{r}
tiff("16sNMDS_Site_IRR.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, shape = "Plot", color = "Site")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_paired)+
  stat_ellipse(type = "norm", linetype = 2, aes(color ="Plot"), show.legend = TRUE) +
  ggtitle("16s NMDS Ordination by Irrigation Method")+
  theme_bw()
dev.off()
```


####Lets explore the other farm variables and factors with the NMDS ordination to visually see if there are more patterns. 


```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "total_precip_irr")+
  geom_point(size = 3)+
  scale_color_gradient(low='#05D9F6', high='#5011D1')+
  ggtitle("16s NMDS Ordination by Total Precipitation")+
  theme_bw()
```


```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "Moisture_Content")+
  geom_point(size = 3)+
  scale_color_gradient(low='#05D9F6', high='#5011D1')+
  ggtitle("16s NMDS Ordination by Moisture Content")+
  theme_bw()
```
####Total mositure content is present but hard to see with the naked eye. 

```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "Tillage")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_dark, breaks=c("Conventional", "Culti-roller", "No_till"),
                    labels=c("Conventional", "Culti Roller", "No Till"))+
  ggtitle("16s NMDS Ordination by Tillage")+
  theme_bw()
```
```{r echo=FALSE}
tiff("16sNMDS_Tillage.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "Tillage")+
  geom_point(size = 3)+
  scale_color_manual(values =  farm_col_dark, breaks=c("Conventional", "Culti-roller", "No_till"),
                    labels=c("Conventional", "Culti Roller", "No Till"))+
  ggtitle("16s NMDS Ordination by Tillage")+
  theme_bw()
dev.off()
```


```{r}
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "prev_crop")+
  geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("16s NMDS Ordination by Previous Crop")+
  theme_bw()
```
```{r echo=FALSE}
tiff("16sNMDS_PreviousCrop.tiff", width = 6, height = 4, units = 'in', res = 600)
plot_ordination(physeq_16s_ord, phy16s_ord_NMDS, color = "prev_crop")+
  geom_point(size = 3)+
  scale_color_manual(values =  c("#1B9E77", "#D95F02", "#7570B3", "#66a61E"),
                    name = "Previous Crop",
                    breaks=c("barley",  "Chem_fallow", "Spring_wheat", "winter_wheat"),
                    labels=c("Barley", "Chemical Fallow", "Spring Wheat", "Winter Wheat"))+
  ggtitle("16s NMDS Ordination by Previous Crop")+
  theme_bw()
dev.off()
```
##Beta dispersions 
####Test the diffrences in group homogeneities. Do our farm managment factors effect the homogeneitiey of the bray curtis distance? 

####If a group (Site) in the MDS space are close but have diffrenent dispersion you could have a signifcant results when it is only a diffrence in dispersion.  


Anderson (2006)-https://www.ncbi.nlm.nih.gov/pubmed/16542252

https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.1461-0248.2006.00926.x

####Irrigation beta dispersion
```{r}
disp_16s_plot <- betadisper(distance(physeq_16s_ord, method = "bray"), meta2$Plot)
permutest(disp_16s_plot, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp_16s_plot)
```
```{r}
plot(disp_16s_plot, hull = FALSE, ellipse = TRUE)
```


```{r}
disp_16s_Till <- betadisper(distance(physeq_16s_ord, method = "bray"), meta2$Tillage)
permutest(disp_16s_Till, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp_16s_Till)
```

```{r}
plot(disp_16s_Till, hull = FALSE, ellipse = TRUE)
```


```{r}
disp_16s_prev_crop <- betadisper(distance(physeq_16s_ord, method = "bray"), meta2$prev_crop)
permutest(disp_16s_prev_crop, pairwise=TRUE, permutations=1000)
```

```{r}
boxplot(disp_16s_prev_crop)
```
```{r}
plot(disp_16s_prev_crop, hull = FALSE, ellipse = TRUE)
```

```{r}
TukeyHSD(disp_16s_prev_crop)

```
```{r}
disp_16s_site <- betadisper(distance(physeq_16s_ord, method = "bray"), meta2$Site)
permutest(disp_16s_site, pairwise=TRUE, permutations=1000)
```
```{r}
boxplot(disp_16s_site)
```
```{r}
TukeyHSD(disp_16s_site)
```
```{r}
farm_col_paired<-(c('#fdbf6f','#ff7f00','#b2df8a','#33a02c','#fb9a99','#e31a1c','#cab2d6','#a6cee3','#1f78b4'))

```

```{r}
dispersion_16s_site<-data.frame(Distance_to_centroid=disp_16s_site$distances, 
                                Site=disp_16s_site$group)
ggboxplot(dispersion_16s_site, x = "Site", y = "Distance_to_centroid",
   rug = TRUE,
   fill = "Site", ylab = "Distance to Centroid", 
   legend = "none",
   title = "Beta Dispersion of 16s Bray-Curtis",
   palette = farm_col_paired)+
  rotate_x_text(45, size = 10)
```

```{r echo=FALSE}
tiff("16s_dispersion_site.tiff", width = 6, height = 4, units = 'in', res = 600)
ggboxplot(dispersion_16s_site, x = "Site", y = "Distance_to_centroid",
   rug = TRUE,
   fill = "Site", ylab = "Distance to Centroid", 
   legend = "none",
   title = "Beta Dispersion of 16s Bray-Curtis",
   palette = farm_col_paired)+
  rotate_x_text(45, size = 10)
dev.off()
```


```{r}
plot(disp_16s_site, hull = FALSE, ellipse = TRUE)
```
```{r}

ggboxplot(dispersion_16s_site, x = "Site", y = "Distance_to_centroid",
   rug = TRUE,
   fill = "Site", ylab = "Distance to Centroid", title = "Beta Dispersion of 16s Bray-Curtis",
   palette = farm_col_paired)+
  theme_bw()+
  rotate_x_text()
```

```{r}
TukeyHSD(disp_16s_site)

```
####The results from the beta dispersion show that we have a significant difference in the heterogeneity of our sites due to each of the farm management factors. We see that there are sites that do not have signficant diffrences and others that do. Beta dispersion cannot except models so we cannot detect if the diffrences are due to nestedness (prev_crop/Site). 

####Due to the design of the experiment it will be hard to determine if the farm management practices are responsible for the variation in bacterial population. 

***

##PERMANOVA (adoins)

####To test if any of the farm amanagment factors are statitically significant will use adonis from vegan to peform a PERMANOVA on the bray curtis distance. This will be able to tell the nestedness of the site and farm management. 

####First try univariate fram managment 
```{r}
adonis(distance(physeq_16s_ord, method = "bray") ~Plot, data = meta2, permutations = 1000)
```

```{r}
adonis(distance(physeq_16s_ord, method = "bray") ~Plot*Site, data = meta2, permutations = 1000, strata = meta2$Site)
```
####Data is nested within Site (Location effect) so the signficance in the bray-curtis dissimilarity with respect to plot is not sinifcant with the data nested due to the lack of reproduction of conditions at each plot. 

####Since there is issues with doing permutated anova over multivatrite data lets try to fit the chemical and farm managment data the NMDS orientation space using the envfit function in vegan 

***
#Model Selection

***

##ENVFIT

####Envfit does not like single variable values so we remove them 
```{r}
meta3<-meta2[,-c(3,4,10,11,27,29,35,38,42,46)]
```

####Will remove Site category like elevation, lat, long etc that do not differentiate between site we can call these all geographical factors as they do not change between sites. 
```{r}
meta3<-meta3[,-c(2,11:13)]
```

####Model fitting will be biased by chemical outliers that are in some plots the best way to avoid this is to determine the outliers (See chemical_analysis.Rmd) and remove the whole variable since functions ENVFIT and BIOENV will remove it if there are any n/a values. 

####Removing Sulfate_Sulfur, Boron, Molybdenum, Potassium, Vanadium, Chromium and Sodium
```{r}
meta3<-meta3[,-c(16,18,21,29,31)]
```

```{r}
envfit16s <- envfit(phy16s_ord_NMDS , meta3, na.rm = TRUE, permu= 10000) 
envfit16s
```
####The envfit function allows us to see the correlation of our envriomental vectors to the bray-curtis species dissmilarity matrix in NMDS space. This is a loose corelation to real linear corelation but it can tell us how the NMDS orinetaion is being driven. 

write to table

```{r echo=FALSE}
envfit_16s <- data.frame((envfit16s$vectors)$arrows, (envfit16s$vectors)$r, (envfit16s$vectors)$pvals )
write.table(envfit_16s, file = "envfit_16s.txt", sep = "\t", quote = FALSE, row.names = T)
```


####Try a quick plot with base r and vegan for the vectors 

```{r}
plot(phy16s_ord_NMDS, display = "sites")
plot(envfit16s, p.max = 0.001 )
```

***
#Model Selection
##Bioenv
###Bioenv is an iterative procedure in that links enviromental variables to community strucutre by seeking the best subset of enviromental variables that explains community strucutre 

***
####Info
###BIOENV
"The function calculates a community dissimilarity matrix using vegdist. Then it selects all possible subsets of environmental variables, scales the variables, and calculates Euclidean distances for this subset using dist. The function finds the correlation between community dissimilarities and environmental distances, and for each size of subsets, saves the best result. There are 2^p-1 subsets of p variables, and an exhaustive search may take a very, very, very long time (parameter upto offers a partial relief)."

###Mantel test 
"Mantel statistic is simply a correlation between entries of two dissimilarity matrices (some use cross products, but these are linearly related). However, the significance cannot be directly assessed, because there are N(N-1)/2 entries for just N observations. Mantel developed asymptotic test, but here we use permutations of N rows and columns of dissimilarity matrix."


***

```{r}
OTU_16s_trim<- as(otu_table(physeq_16s_ord ), "matrix")
```



```{r}
#Transpose the data to have sample names on rows
abund_table16s<-t(OTU_16s_trim)

nrow(abund_table16s)
```



```{r}
setdiff(rownames(meta3), rownames(abund_table16s))
```
Our meta data and sample data match with 0 diffrence in rownames


####will use parallel processing to speed up calculations 

```{r}
#First detect amount of cores avalible 
detectCores()
```

```{r}
#get bray-curtis distance
abund_dist16s<-vegdist(abund_table16s, method = "bray")
#make bioenv model against whole meta table with ".", and use gower metric to measure distance in order to incroprate the factor variables. Model will be used up to 7 vriables in final model. parelle processing on 10 cores
#n16s.bioenv <- bioenv(abund_dist16s ~ ., meta3, index = "bray", method = "pearson", 
  #                    metric = "gower", upto = 7, parallel = 10)

#summary(n16s.bioenv)
```

```{r}
#n16s.bioenvdist<-bioenvdist(n16s.bioenv, which = "best")
#mantel(n16s.bioenvdist, abund_dist16s)
```


```{r}
#n16s.bioenv$whichbest
```
####Try BioENV without site, this will favor farm managment variables since they are nested within. 

####Remove site from meta table
```{r}
meta4<-meta3[,-c(1)]
```

####Rerun BioEnv

```{r}
#n16s.bioenv.site.na <- bioenv(abund_dist16s ~ ., meta4, index = "bray", 
                      #        method = "pearson", metric = "gower", upto = 7, parallel = 10)

#summary(n16s.bioenv.site.na)
```

```{r}
#n16s.bioenvdist.site.na<-bioenvdist(n16s.bioenv.site.na, which = "best")
#mantel(n16s.bioenvdist.site.na, abund_dist16s)
```

```{r}
#n16s.bioenv.chem <- bioenv(abund_dist16s ~ Organic_Matter + Moisture_Content + 
 #                              Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium + 
  #                              pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium +
   #                             Manganese + Nickel + Phosphorus + Sulfur + Zinc, meta3, 
    #                          index = "bray", method = "pearson", metric = "gower",
     #                         upto = 7, parallel = 10)

#summary(n16s.bioenv.chem)
```


```{r}
#n16s.bioenvdist.chem<-bioenvdist(n16s.bioenv.chem, which = "best")
#mantel(n16s.bioenvdist.chem, abund_dist16s)
```

```{r}
#n16s.bioenv.chem$whichbest
```
***

##CCA/ordistep model selection

####CCA model selection uses a procedure to take the a constrained distance ordination with the complete model and compare it with a unconstrainted model. The model starts with no variables then adds variables that make the best model. These models can then be plotted against the smae ordination space as vectors.

####Ordistep use Akaike information criterion (AIC) which is a estimator of relative quality of the models. AIC is relative to models you are comparing when you compare two models the one with the lower AIC is favored.  


```{r}
m1_16 <- cca(abund_table16s ~ ., meta3)
m0_16 <- cca(abund_table16s ~ 1, meta3)
m1_16
m0_16
```


####Ordistep

```{r results="hide"}
model_16s <-ordistep(m0_16, scope=formula(m1_16))
```

```{r}
model_16s$anova
```

####Site is again nesting the data in the model selection


####CCA without site
```{r}
m1_16_site_na <- cca(abund_table16s ~ ., meta4)
m0_16_site_na <- cca(abund_table16s ~ 1, meta4)
m1_16_site_na
m0_16_site_na
```

####Ordistep

```{r results="hide"}
model_16s_site_na <-ordistep(m0_16_site_na, scope=formula(m1_16_site_na))
```

```{r}
model_16s_site_na$anova
```

####Will use CCA modeling with only chemistry data

```{r}
colnames(meta3)
```

Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH +
Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc
```{r}

#m1_16_cca_chem <- cca(abund_table16s ~ Organic_Matter + Moisture_Content + 
  #                      Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium + 
   #                     pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + 
 #                       Manganese + Nickel + Phosphorus + Sulfur + Zinc , meta3)
#m0_16_cca_chem <- cca(abund_table16s ~ 1, meta3)
#m1_16_cca_chem
#m0_16_cca_chem
```

```{r results="hide"}
#model_16s_cca_chem <-ordistep(m0_16_cca_chem, scope=formula(m1_16_cca_chem))
```
```{r}
#model_16s_cca_chem$anova
```



####Constrained Ordination plot in ggplot 
http://deneflab.github.io/MicrobeMiseq/demos/mothur_2_phyloseq.html#constrained_ordinations


##CCA with selected model from Chemical CCA model 
```{r warning=FALSE}
# CCA ordinate
cca_ord_16s <- ordinate(
    physeq = physeq_16s_ord, 
    method = "CCA",
    distance = abund_distnifH,
    formula = ~  Zinc + Magnesium + Phosphorus + Sulfur + Av_Potassium + 
      Organic_Matter + Manganese + Ammonia  )

# CCA plot
cca_plot_16s <- plot_ordination(
  physeq = physeq_16s_ord, 
  ordination = cca_ord_16s, 
    color = "Site",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_16s_cca <- vegan::scores(cca_ord_16s, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_16s_cca)

#Multiply biplot by scaling multiplier
arrowmat_16s_cca_scale<-arrowmat_16s_cca*2

# Add labels, make a data.frame
arrowdf_16s_cca <- data.frame(labels = rownames(arrowmat_16s_cca_scale), arrowmat_16s_cca_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CCA1, 
    yend = CCA2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3* CCA1, 
    y = 1.3 * CCA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cca_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_16s_cca, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_16s_cca, 
    show.legend = FALSE
  )+
  ggtitle("CCA plot constrained ordination of 16s with selected Chemistry Model")+
  theme_bw()
```





####RDA is a linear cca and offers a R2 option in OrdiR2step
```{r}
m1_16_rda <- rda(abund_table16s ~ ., meta3)
m0_16_rda <- rda(abund_table16s ~ 1, meta3)
m1_16_rda
m0_16_rda
```

```{r}
plot(m1_16_rda)
```


```{r results="hide"}
model_rda_16s <-ordiR2step(m0_16_rda, scope=formula(m1_16_rda))
```

```{r}
model_rda_16s$anova
```



```{r}

m1_16_rda_chem <- rda(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc , meta3)
m0_16_rda_chem <- rda(abund_table16s ~ 1, meta3)
m1_16_rda_chem
m0_16_rda_chem
```

```{r}
plot(m1_16_rda_chem)
```


```{r results="hide"}
model_rda_chem_16s <-ordiR2step(m0_16_rda_chem, scope=formula(m1_16_rda_chem))
```
####Again the above analysis does not consider the site effect but I think we are ok with that because all of the chemcial vriables are "idependent" (sorta). I am not personally as confident in publishing this as I am with the envfit or bioenv since those are in non-metric space and have less correlation to actuall species distance. 

```{r}
model_rda_chem_16s$anova
```

###RDA with selected model from Chemical RDA model 
```{r}
# RDA ordinate
rda_ord_16s <- ordinate(
    physeq = physeq_16s_ord, 
    method = "RDA",
    distance = abund_dist16s,
    formula = ~   Av_Phosphorus + Sulfur + Magnesium + Zinc + Av_Potassium + Manganese )

# RDA plot
rda_plot_16s <- plot_ordination(
  physeq = physeq_16s_ord, 
  ordination = rda_ord_16s, 
    color = "Site",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_16s_rda <- vegan::scores(rda_ord_16s, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_16s_rda)

#Multiply biplot by scaling multiplier
arrowmat_16s_rda_scale<-arrowmat_16s_rda*150

# Add labels, make a data.frame
arrowdf_16s_rda <- data.frame(labels = rownames(arrowmat_16s_rda_scale), arrowmat_16s_rda_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = RDA1, 
    yend = RDA2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3* RDA1, 
    y = 1.3 * RDA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
rda_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_16s_rda, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_16s_rda, 
    show.legend = FALSE
  )+
  ggtitle("RDA plot constrained ordination of 16s with selected Chemistry Model")+
  theme_bw()
```
####Removed Organic matter since the ordination was so low. 
```{r echo=FALSE}
tiff("16sRDA_chem.tiff", width = 6, height = 4, units = 'in', res = 600)
rda_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_16s_rda, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_16s_rda, 
    show.legend = FALSE
  )+
  ggtitle("RDA plot constrained ordination of 16s with selected Chemistry Model")+
  theme_bw()
dev.off()
```





###CAP model building
####canonical analysis of principal coordinates (CAP) is similar to RDA but allows for non-euclidian dissimilarity like Bray-Curtis which we have been using. 

https://esajournals.onlinelibrary.wiley.com/doi/epdf/10.1890/0012-9658%282003%29084%5B0511%3ACAOPCA%5D2.0.CO%3B2

###Guide for the CAP Ordination 

####https://quantpalaeo.wordpress.com/2014/04/14/variance-inflation-factors-and-ordination-model-selection/

####If the VIF of a predictor is high, it indicates that that predictor is highly correlated with other predictors, it contains little or no unique information, and there is redundancy in the set of predictors.

####STEPS
    1)Generate a constrained ordination with all available predictors.
    2)Calculate the VIF of each variable.
    3)If any variable has a VIF over a threshold (typically 10), drop the variable with the highest VIF
    4)Repeat until all remaining variables have a VIF below the threshold.

```{r}
m1_16s_cap_chem<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Sulfur + Zinc , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem)
```
```{r}
vif.cca(m1_16s_cap_chem)
```

####Lots of high VIF scores, this might take a while, 

####Droping Sulfur from the model 

```{r}
m1_16s_cap_chem_1<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus + Zinc , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_1)
```

```{r}
vif.cca(m1_16s_cap_chem_1)
```
####Dropping Zinc from the model 

```{r}
m1_16s_cap_chem_2<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Copper + Iron + Magnesium + Manganese + Nickel + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_2)
```

```{r}
vif.cca(m1_16s_cap_chem_2)
```
####Dropping Copper

```{r}
m1_16s_cap_chem_3<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Iron + Magnesium + Manganese + Nickel + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_3)
```
```{r}
vif.cca(m1_16s_cap_chem_3)
```
####Dropping Iron

```{r}
m1_16s_cap_chem_4<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Magnesium + Manganese + Nickel + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_4)
```
```{r}
vif.cca(m1_16s_cap_chem_4)
```
####Removing Magnesium Getting close!

```{r}
m1_16s_cap_chem_5<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Manganese + Nickel + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_5)
```
```{r}
vif.cca(m1_16s_cap_chem_5)
```
####Dropping Nickel
```{r}
m1_16s_cap_chem_6<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium +  pH + Barium + Calcium + Cobalt + Manganese + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_6)
```

```{r}
vif.cca(m1_16s_cap_chem_6)
```

####Droping pH
```{r}
m1_16s_cap_chem_7<- capscale(abund_table16s ~ Organic_Matter + Moisture_Content + Nitrate_Nitrite + Ammonia + Av_Phosphorus + Av_Potassium + Barium + Calcium + Cobalt + Manganese + Phosphorus , data = meta3, distance = "bray")
m0_16s_cap_chem<- capscale(abund_table16s ~ 1, meta3)
plot(m1_16s_cap_chem_7)
```
```{r}
vif.cca(m1_16s_cap_chem_7)
```

####Everything under 10! We will put these variables into the model building because it will not have co lineraity 



```{r results="hide"}
model_cap_chem_16s <-ordiR2step(m0_16s_cap_chem, scope=formula(m1_16s_cap_chem_7))
```

```{r}
aov_model_cap_chem_16s<-model_cap_chem_16s$anova
aov_model_cap_chem_16s
```
```{r}
capture.output(aov_model_cap_chem_16s,file="aov_model_cap_chem_16s.txt")
```


####Our CAP Model explains 51% of the variance in our Bray-Curtis distances 
```{r}
stressplot(m1_16s_cap_chem_7)
```
```{r}
screeplot(m1_16s_cap_chem_7)
```
```{r warning=FALSE}
# CAP ordinate
cap_ord_16s <- ordinate(
    physeq = physeq_16s_ord, 
    method = "CAP",
    distance = abund_dist16s,
    formula = ~   Av_Phosphorus + Barium + Calcium + Av_Potassium + 
      Manganese + Organic_Matter + Cobalt + Nitrate_Nitrite  )

# CCA plot
cap_plot_16s <- plot_ordination(
  physeq = physeq_16s_ord, 
  ordination = cap_ord_16s, 
    color = "Site",
    shape = "Plot",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 

# Now add the environmental variables as arrows
arrowmat_16s_cap <- vegan::scores(cap_ord_16s, display = "bp")

#Get appropiate scalling multipler 
mul<-vegan::ordiArrowMul(arrowmat_16s_cap)

#Multiply biplot by scaling multiplier
arrowmat_16s_cap_scale<-arrowmat_16s_cap*1.9
# Add labels, make a data.frame
arrowdf_16s_cap <- data.frame(labels = rownames(arrowmat_16s_cap_scale), arrowmat_16s_cap_scale)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CAP1, 
    yend = CAP2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = 1.3* CAP1, 
    y = 1.3 * CAP2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cap_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_16s_cap, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_16s_cap, 
    show.legend = FALSE
  )+
  ggtitle("CAP plot constrained ordination of 16s with selected Chemistry Model")+
  theme_bw()
```

#```{r echo=FALSE}
tiff("16sCAP_chem.tiff", width = 8, height = 5, units = 'in', res = 600)
cap_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf_16s_cap, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = arrowdf_16s_cap, 
    show.legend = FALSE
  )+
  ggtitle("CAP plot Constrained Ordination of 16s with Selected Chemistry Model")+
  theme_bw()
dev.off()
#```


#### Fitting species to cap plot 
```{r}
m1_16s_cap_chem_species<- capscale(abund_table16s ~ Av_Phosphorus + Barium + Calcium + Av_Potassium + 
      Manganese + Organic_Matter + Cobalt + Nitrate_Nitrite, data = meta3, distance = "bray")
dims=c(1,2)
site=scores(m1_16s_cap_chem_species,display="wa",choices=dims)
cor.min=0.9 #below this threshold, arrows will be not plotted 
#because orrelation is considered too much week
cor_sp=as.data.frame(scores(m1_16s_cap_chem_species, dis="sp", scaling=1,choices=dims))
cor_sp$cor=with(cor_sp,sqrt(CAP1^2+CAP2^2))
cor_sp$sup=FALSE;cor_sp$sup[cor_sp$cor>=cor.min]<-TRUE
cor_sp$labels=row.names(cor_sp)
cor_sp=cor_sp[cor_sp$sup==TRUE,]
cor_sp_s1=cor_sp



```


```{r}
tax_16s_cap<- read.delim("~/Alex Alleman/Statewide Microbiome Analysis/Statewide analysis/16s_OTU_ids_2016_fixed.txt", row.names = 1, colClasses = c(rep('character', 8) ))
head(tax_16s)[,1:8]

#use perl scirpt to remove teh g_
tax_16s_cap$species<- sub(".*_", "", tax_16s_cap$species)
#use the function captilize to captilize first letter
tax_16s_cap$species<- capitalize(tax_16s_cap$species)

species_16s<-merge(cor_sp_s1, tax_16s_cap, by="row.names")


```


Replot with species
```{r warning=FALSE}
# CAP ordinate
cap_ord_16s <- ordinate(
    physeq = physeq_16s_ord, 
    method = "CAP",
    distance = abund_dist16s,
    formula = ~   Av_Phosphorus + Barium + Calcium + Av_Potassium + 
      Manganese + Organic_Matter + Cobalt + Nitrate_Nitrite  )

# CCA plot
cap_plot_16s <- plot_ordination(
  physeq = physeq_16s_ord, 
  ordination = cap_ord_16s, 
    color = "Site",
    shape = "Plot",
    axes = c(1,2)) + 
    geom_point(aes(colour = Site), size = 3) + 
    scale_color_manual(values =  farm_col_paired) 



# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CAP1, 
    yend = CAP2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL,
    label = species)

label_map <- aes(x = 1.3* CAP1, 
    y = 1.3 * CAP2, 
    shape = NULL, 
    color = NULL, 
    label = species)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cap_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = species_16s, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = species_16s, 
    show.legend = FALSE,
    fontface="italic"
  )+
  ggtitle("CAP plot constrained ordination of 16s with Correlated Species")+
  theme_bw()
```


```{r echo=FALSE}
tiff("16sCAP_species.tiff", width = 8, height = 5, units = 'in', res = 600)
cap_plot_16s + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = species_16s, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text_repel(
    mapping = label_map, 
    size = 4,  
    data = species_16s, 
    show.legend = FALSE,
    fontface="italic"
  )+
  ggtitle("CAP plot constrained ordination of 16s with Correlated Species")+
  theme_bw()
dev.off()
```










